<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 记录</title>
    <link>https://ffzznjxk.github.io/post/</link>
    <description>Recent content in Posts on 记录</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 08 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ffzznjxk.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>选择集合与几何变换</title>
      <link>https://ffzznjxk.github.io/p/new-project-3/</link>
      <pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/new-project-3/</guid>
      <description>选择集 选择集   获取选择
Editor.GetSelection()
  选择的内容
  SelectionSet = PromptSelectionResult.Value ObjectId[] = SelectionSet.GetObjectIds()
  类型DxfName
ObjectId.ObjectClass.DxfName
  /// &amp;lt;summary&amp;gt;  /// 按DxfName分类对象  /// &amp;lt;/summary&amp;gt; [CommandMethod(&amp;#34;SED&amp;#34;, CommandFlags.UsePickSet)] public void SelectEntityDxf() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; ////命令之前选中  //var psrAleady = ed.SelectImplied();  //选择集  var pso = new PromptSelectionOptions(); pso.MessageForAdding = &amp;#34;选择对象\n&amp;#34;; var psr = ed.GetSelection(pso); ////全部选中  //var psrA = ed.SelectAll();  //选择集  //PromptSelectionResult psrPolygon, psrCw, psrW;  ////选择多线段  //var per = ed.</description>
    </item>
    
    <item>
      <title>用户交互与几何图形</title>
      <link>https://ffzznjxk.github.io/p/new-project-2/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/new-project-2/</guid>
      <description>输入输出 输入  获取点提示 PromptPointOptions() 获取点结果 ed.GetPoint() 状态 PromptStatus.OK  输出  输出信息 ed.WriteMessage()  /// &amp;lt;summary&amp;gt;  /// 提示选择点  /// &amp;lt;/summary&amp;gt; [CommandMethod(&amp;#34;PromptSelectPoint&amp;#34;)] public void PromptSelectPoint() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取点提示  var ppo = new PromptPointOptions(&amp;#34;\n指定起点&amp;#34;); //获取点结果  var ppr = ed.GetPoint(ppo); //结果状态为OK  if (ppr.Status == PromptStatus.OK) { //起点  Point3d startPt = ppr.Value; ppo = new PromptPointOptions(&amp;#34;\n指定终点&amp;#34;); ppr = ed.</description>
    </item>
    
    <item>
      <title>2020年记忆</title>
      <link>https://ffzznjxk.github.io/p/2020summary/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/2020summary/</guid>
      <description>变化  2020年时光流逝，这一年有很多变化和新的开始，需要回忆记录下。
 年初在家，是我这些年在家过的时间最长的一个年，过年变得淡然起来。感受到随着年岁增长，家人需要陪伴、身体需要修养。一直到三月初才从老家回到昆山，见到妻儿。
 回到办公室，当时还是很茫然的，不知道这一年是否又像之前一样重复无所成长。刚开始在推用协奕软件方案工具，我做一些资料，过程中大家提了一些问题，也只能在我会的基础上修修改改。在某一个中午，于工召集陈总、骆工和我在会议室讨论图纸，说了一些参照、视口、区域覆盖的一些内容，并没有什么结论，只是证明了一些事情。骆工建议去了解设计师的需求，想着做一个好用的功能去实现。
 四月中旬开始，从头开始看邵工写的剖立面功能（以前不敢深入，怕各种方法我会找不到方向）到逐渐理解。网上找资料，在基础上新增一些改动，在五一前终于有个初始的新剖立面给建筑设计师用，但当时存在许多错误以及不稳定。五月我去了一趟杭州和小左游了西湖，受到了一些肯定，坚定了要做下去的想法。重新开始看了AutoCAD开发基础、C#图解教程这些一直看不完的书（到现在还没看完）；新买了一些书，一本何教授写的《几何计算》给了我方向和方法，重新了解向量、直线方程式（再也到不学校时期的证明解题水平），给了更多可能。期间张莉一直给予我很多支持和配合，不断新增了一些小功能，过程中让自己的技能水平有了一点成长，才知道自已一直是门槛水平。
 逆风——花园精灵
  因为一些变动，我需要一些安静环境。七月开始我在昆山办公，有了一定自由，我要去努力实现2020年的想法，从一张已知的平面图纸绘制配套图纸。截取-&amp;gt;标注-&amp;gt;标高-&amp;gt;剖立面-&amp;gt;图纸。截取就是从平面图纸局部内容，从复制开始，分类、打断、轴线轴号、剪切。从AutoCAD支持的方法不断尝试，创建、处理一些看似存在的过程，不断前行。
图1.gif
 设计时用了天正，觉得简单方便，便于批量修改，哪里能用就用。二次开发中遇到天正对象就是个未知，什么也找不到，什么也用不上，希望天正内容通通分解。要想标注只能依靠AutoCAD的标注，仔细看书标注就是两点一线这么简单。图纸上无外乎是在正交方向的标注，那么只要会画线就可以探索图形去标注，原来简单的对象如此强大。
图2.gif
 对于天正的无知，会和设计师画图方法脱离，重复的分解产生更多的误差。在八月的某天一次调试中发现了天正的秘密，在邵工的提示下找到了认知的方法，终于重新认识了天正对象，让后续的功能准确识图建立了良好基础。之后空余时间做了一个新的给排水套管工具，从设计师角度填入一些必要设计参数，识别图纸按设计需求添加套管、记录信息、添加代号、生成表格、添加大样，用一个窗口解决一张图的事。
图3.gif
 标高是生成剖立面关键的参数，从设计师的口中获得了初始的标高系，剖切符号是图纸转向另外一个平面坐标系的关键节点。形状由几何元素组成，相互约束结构成图，从画法几何角度去计算图形，实际是一场数据交换过程。通过设置标高、添加剖切号、平面识别、图形转换、重建图形，能相对完整的去表达一个建筑详图。
图4.gif
 也可以用新的方法解决以前的问题。
图5.gif
2020更新
协奕软件更新
 开始  在这些实验过程中也让请张莉在图纸中不断试错，时不时出现未知的问题，有的只能让它Catch Continue。需求、想象是多种多样的，我还需要耐心去学习，还需要时间去成长。下半年来最多的感觉是时间不够，不够我去学习，不够我去尝试，不够去解决问题，不够去应对变化，不够我去生活。我还有很多学习在收藏夹，还有很多可能要去尝试，还有很多问题要去解决，只希望时间能等等我，不要有过多压力去面对生活。
 飞机云——《起风了》
  这一年要感谢的人很多，有些来不及说声谢谢。还是要感谢下老板，对我的支持。还有很多期待，希望有一个好的开始去探索2021年的未知。
动态的可能
李元宏
2021.01.15</description>
    </item>
    
    <item>
      <title>2020的更新</title>
      <link>https://ffzznjxk.github.io/p/2020update/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/2020update/</guid>
      <description>2020.9.27更新  增加平面截取功能。绘制截取框直接对平面图形（包含块参照），生成截取框内图形，裁剪边界图形，并对裁剪框指定范围内部分设计图形进行标注。

功能更新如下：  绘制截取框； 裁剪截取框； 截取平面； 设置截面参数；  
功能说明  绘制截取框：指定两点添加截取框（图层：JA-索引，线型：DASH，线宽：100，圆角可设置）。 裁剪截取框：指定两点裁剪已存在的截取框（仅支持单段裁剪），生成新的截取框（裁剪位置处目前非圆角）。 截取平面：选择已添加的截取框，指定位置生成截面内容，生成的截面遵循一下规则：   3.1	截取的人防门及文字按截取比例（可设置）设置，天正的内容需用天正的比例修改。 3.2	截取生成的内容包含截取框内对象，截取边界打断曲线对象（包括直线、多线段、圆、天正墙体等），对块图形剪切。 3.3	截取内容会忽略删除图层（可设置）的对象，对位于底图图层（可设置）的图块内对象再次截取。 3.4	轴线识别参数：在模型空间或底图图块，直线、DOTE线型，轴号识别参数：图块（块名：_AXISO）、圆或者天正图名索引，在轴线延长范围内。 3.5	截取内容下方会生成图名，并与截取框引注向关联。图名命名以截取的房间名称最多次数（可设置）的为准。 3.6	对与折断线标注探索范围内对象进行标注，目前支持的标注对象包括天正墙体、柱子、门洞，我院建筑图层下的混凝土墙、砖墙、柱子、轴线。  
参数设置   4.1	截面间距：设置两个连续截面上下距离； 4.2	详图比例：生成的截面内容的比例，主要与文字、门窗型号有关。； 4.3	轴号距离：轴线端点与折断线的距离； 4.4	折断超出：相交的折断线超出的尺寸； 4.5	标注探索：相对折断线范围内指定类型对象（一般垂直折断线）进行标注； 4.6	截取圆角：设置截取框圆角大小； 4.7	第二尺寸：标注的第二道尺寸线与第三道尺寸距离； 4.8	第三尺寸：标注的第三道尺寸线与折断线距离。 4.9	底图内容：该图层的图块会块内对象再次截取，可选择对象按图层添加。 4.10	删除内容：忽略该图层对象，不会被截取，可选择对象按图层添加。 4.11	图名设置：根据列表内容命名图名，图名是以房间名称出现最多的名称命名，可右键该列表，增加、修改、删除内容。   平面截取是剖立面功能的一部分，相对之前支持了天正的对象，后续还会改进协奕标注、新剖立面等功能，使其完善更加一体化。也需要大家多试用，提出意见。让画图不要太难，不用太累。
李元宏
2020.9.27
 2020.7.1更新  最近在做详图标注，可对详图平面进行标注。</description>
    </item>
    
    <item>
      <title>一个新项目</title>
      <link>https://ffzznjxk.github.io/p/new-project/</link>
      <pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/new-project/</guid>
      <description>一个新项目 Visual Studio 1. 安装  登陆 语言  2. 创建新项目  解决方案 项目 项  3. HelloWorld  using namespace class  4. 工具  代码片段  5. 调试  断点 条件 监视（自动窗口/局部变量）  AutoCAD 1. 注册 2. 命令  line/point/vector/circle copy/move/scale/mirror block/dim/text  ObjectARX 1. 类库(.Net Framework)  4.5.2 AcDbMgd AcMgd  2. HelloWord  Editor Application  3. 调试  设为启动项 启动外部程序 NetLoad  4. Line  F12   /// &amp;lt;summary&amp;gt;  /// 新建直线(newline)  /// &amp;lt;/summary&amp;gt; [CommandMethod(&amp;#34;newline&amp;#34;)] public void NewLine() { //定义直线，起点：100, 100, 0；终点：300, 200, 0  Line line = new Line(new Point3d(100, 100, 0), new Point3d(300, 200, 0)); //打开当前图形数据库  Database db = HostApplicationServices.</description>
    </item>
    
    <item>
      <title>几何算法问题1</title>
      <link>https://ffzznjxk.github.io/p/geomath-problem1/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/geomath-problem1/</guid>
      <description>向量投影问题  在一个二维坐标系中一条线段Line_ab，起终点分别为A(100,100)，B(300,200)，一条线段Line_cd，起终点分别为C(100,200)，D(150,225)。 已知条件 计算Line_cd投影到Line_ab上的线段 ( 如下图所示Line_ef )。 计算投影线段</description>
    </item>
    
    <item>
      <title>图形计算</title>
      <link>https://ffzznjxk.github.io/p/mathcode-data/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/mathcode-data/</guid>
      <description>概况 图形计算编程主要分两部分内容 1. 算法  几何计算 数据运算  2. 编程  C# 方法 AutoCAD 接口  对于平面设计（建筑行业）主要对象是二维图形，用到的几何计算主要与点、线、框的计算方法；数据运算主要是按照功能需求，对已有的数据准确有效处理。 因为平面设计主要使用 AutoCAD 软件开发，而 AutoCAD 支持 .net 开发，其中 C# 语言易于上手，相关功能资料齐全，易于软件开发使用。
学习资料 1. 几何计算  《几何计算》 何援军 著，该书讲解二维、三维图形基础计算方法，并用 C++ 给出代码示例，是一本很好的几何计算入门书籍。该书没有电子版，可在京东购买。  2. C#  《C#图解教程》（第4版） 该书介绍了 C# 语言特性，用一些图示方法展示基本原理，适合打好编程语言基础。 《C#本质论》（第4版） 适合扩展提高。 C#入门到精通 这是一套比较全面的视频资料，不过需要很多时间浏览，适合看书遇到疑问时找视频相关内容了解。 C# 菜鸟教程 简明的语言教程网站，适合临时找内容。 C# 官方文档 最全最专业的官方文档，适合深入研究。  3. 算法  《算法》（第4版） 一本专业的算法书籍，让计算简单而有效。 算法第四版 - Course课程 这是上面这本书的视频教程。 Leetcode 题解 Leetcode 是一个专门是算法解题网站，这是一个挑选了常用算法的网站，可以学习这些算法用于解决可能的问题。  4. AutoCAD 二次开发  《Auto CAD VBA&amp;amp;VB.</description>
    </item>
    
    <item>
      <title>算法学习2021-01-04</title>
      <link>https://ffzznjxk.github.io/p/leetcode-2021-01-04/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/leetcode-2021-01-04/</guid>
      <description>分配饼干 Input: grid[1,3], size[1,2,4]Output: 2public class Solution { public int FindContentChildren(int[] g, int[] s) { Array.Sort(s); Array.Sort(g); int child = 0, cookie = 0; while(child &amp;lt; g.Length &amp;amp;&amp;amp; cookie &amp;lt; s.Length) { if(g[child] &amp;lt;= s[cookie]) child++; cookie++; } return child; } } 不重叠的区间个数 Input: [ [1,2], [1,2], [1,2] ]Output: 2Input: [ [1,2], [2,3] ]Output: 0</description>
    </item>
    
    <item>
      <title>算法学习2020-12-30</title>
      <link>https://ffzznjxk.github.io/p/leetcode-2020-12-30/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/leetcode-2020-12-30/</guid>
      <description>按颜色进行排序 Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2]public class Solution { public void SortColors(int[] nums) { int z = 0, t = nums.Length - 1; for (int i = 0; i &amp;lt; nums.Length; i++) { if (nums[i] == 0) { int tmp = nums[z]; nums[z++] = nums[i]; nums[i] = tmp; } } for (int i = nums.Length - 1; i &amp;gt;= z; i--) { if (nums[i] == 2) { int tmp = nums[t]; nums[t--] = nums[i]; nums[i] = tmp; } } } } </description>
    </item>
    
    <item>
      <title>算法学习2020-12-29</title>
      <link>https://ffzznjxk.github.io/p/leetcode-2020-12-29/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/leetcode-2020-12-29/</guid>
      <description>按照字符出现次数对字符串排序 Input:&amp;quot;tree&amp;quot;Output:&amp;quot;eert&amp;quot;Explanation:&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &amp;quot;eetr&amp;quot; is also a valid answer.public class Solution { public string FrequencySort(string s) { var list = s.ToCharArray().GroupBy(d =&amp;gt; d) .ToDictionary(d =&amp;gt; d.Key, d =&amp;gt; d.Count()).ToList(); list.Sort((p1, p2) =&amp;gt; p2.Value.CompareTo(p1.Value)); StringBuilder result = new StringBuilder(); foreach (var l in list) for (int i = 0; i &amp;lt; l.</description>
    </item>
    
    <item>
      <title>CADRibbon</title>
      <link>https://ffzznjxk.github.io/p/autocad-ribbon/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/autocad-ribbon/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CAD资料</title>
      <link>https://ffzznjxk.github.io/p/autocad-data/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/autocad-data/</guid>
      <description>&lt;h1 id=&#34;cad-开发学习资料集合&#34;&gt;CAD 开发学习资料集合&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>算法学习2020-12-22</title>
      <link>https://ffzznjxk.github.io/p/leetcode-2020-12-22/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/leetcode-2020-12-22/</guid>
      <description>找到倒数第 k 个的元素 Given [1,1,1,2,2,3] and k = 2, return [1,2].public class Solution { public int FindKthLargest(int[] nums, int k) { return nums.OrderByDescending(d =&amp;gt; d).ToArray()[k - 1]; } } 出现频率最多的 k 个元素 Given [1,1,1,2,2,3] and k = 2, return [1,2].public class Solution { public int[] TopKFrequent(int[] nums, int k) { return nums.GroupBy(d =&amp;gt; d) .OrderByDescending(d =&amp;gt; d.Count()) s.Select(d =&amp;gt; d.Key).Take(k).ToArray(); } } </description>
    </item>
    
    <item>
      <title>算法学习2020-12-21</title>
      <link>https://ffzznjxk.github.io/p/leetcode-2020-12-21/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/leetcode-2020-12-21/</guid>
      <description>&lt;h2 id=&#34;双指针&#34;&gt;双指针&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>算法学习2020-12-19</title>
      <link>https://ffzznjxk.github.io/p/leetcode-2020-12-19/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/leetcode-2020-12-19/</guid>
      <description>回文字符串 Input: &amp;quot;abca&amp;quot;Output: TrueExplanation: You could delete the character &#39;c&#39;.可以删除一个字符，判断是否能构成回文字符串。
public class Solution { public bool ValidPalindrome(string s) { for (int i = 0, j = s.Length - 1; i &amp;lt; j; i++, j--) if (s[i] != s[j]) return IsPalindrome(s, i + 1, j) || IsPalindrome(s, i, j - 1); return true; } private static bool IsPalindrome(string s, int i, int j) { while (i &amp;lt; j) if (s[i++] !</description>
    </item>
    
    <item>
      <title>算法学习2020-12-18</title>
      <link>https://ffzznjxk.github.io/p/leetcode-2020-12-18/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/leetcode-2020-12-18/</guid>
      <description>&lt;h2 id=&#34;双指针&#34;&gt;双指针&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>第一篇博客</title>
      <link>https://ffzznjxk.github.io/p/first-blog/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ffzznjxk.github.io/p/first-blog/</guid>
      <description>这是第一篇博客,记录一下.</description>
    </item>
    
  </channel>
</rss>
