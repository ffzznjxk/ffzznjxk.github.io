[{"content":"选择集 选择集   获取选择\nEditor.GetSelection()\n  选择的内容\n  SelectionSet = PromptSelectionResult.Value ObjectId[] = SelectionSet.GetObjectIds()\n  类型DxfName\nObjectId.ObjectClass.DxfName\n  /// \u0026lt;summary\u0026gt;  /// 按DxfName分类对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;SED\u0026#34;, CommandFlags.UsePickSet)] public void SelectEntityDxf() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; ////命令之前选中  //var psrAleady = ed.SelectImplied();  //选择集  var pso = new PromptSelectionOptions(); pso.MessageForAdding = \u0026#34;选择对象\\n\u0026#34;; var psr = ed.GetSelection(pso); ////全部选中  //var psrA = ed.SelectAll();  //选择集  //PromptSelectionResult psrPolygon, psrCw, psrW;  ////选择多线段  //var per = ed.GetEntity(new PromptEntityOptions(\u0026#34;选择一条多线段\u0026#34;));  //if (per.Status == PromptStatus.OK)  //{  // //转换多线段  // var pl = per.ObjectId.GetObject(OpenMode.ForRead) as Polyline;  // if (pl != null)  // {  // //顶点集合  // var pts = new Point3dCollection();  // for (int i = 0; i \u0026lt; pl.NumberOfVertices; i++)  // {  // pts.Add(pl.GetPoint3dAt(i));  // }  // //区域选择(叉选)  // psrPolygon = ed.SelectCrossingPolygon(pts);  // }  //}  //if (ed.GetTwoPoints(out Point3d ptStart, out Point3d ptEnd))  //{  // //叉选  // psrCw = ed.SelectCrossingWindow(ptStart, ptEnd);  // //窗选  // psrW = ed.SelectWindow(ptStart, ptEnd);  //}  if (psr.Status == PromptStatus.OK) { ////设置选中内容  //ed.SetImpliedSelection(psrA.Value);  ////清空选中  //ed.SetImpliedSelection(new ObjectId[0]);  //选中对象Id数组  var ids = psr.Value.GetObjectIds(); if (ids.Length \u0026gt; 0) { //按DxfName分组  var gIds = ids.GroupBy(d =\u0026gt; d.ObjectClass.DxfName); //提示信息  string info = string.Empty; foreach (var id in gIds) { info += $\u0026#34;\\n选中 {id.Key} 类型 {id.Count()} 个；\u0026#34;; } AcadApp.ShowAlertDialog(info); ////  //var infos = gIds.Select(d =\u0026gt; $\u0026#34;\\n选中 {d.Key} 类型 {d.Count()} 个；\u0026#34;).ToArray();  //AcadApp.ShowAlertDialog(string.Join(\u0026#34;\\n\u0026#34;, infos));  } } } 条件选择  已选择对象(CommandFlags.UsePickSet)  Editor.SelectImplied()\n 全部选择  Editor.SelectAll();\n 多边形选择  Editor.SelectCrossingPolygon(Point3dCollection polygon)\n 叉选  SelectCrossingWindow(Point3d pt1, Point3d pt2)\n 窗选  SelectWindow(Point3d pt1, Point3d pt2)\n 设置选择内容  SetImpliedSelection(SelectionSet)\n删除对象  实体删除(可写状态)  Entity = (Entity)id.GetObject(OpenMode.ForWrite); Entity.Erase();\n/// \u0026lt;summary\u0026gt;  /// 按DxfName分类对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DE\u0026#34;, CommandFlags.UsePickSet)] public void DeleteEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; //命令之前选中  var psrAleady = ed.SelectImplied(); //选择状态  if (psrAleady.Status == PromptStatus.OK) { //选中对象Id数组  var ids = psrAleady.Value.GetObjectIds(); if (ids.Length \u0026gt; 0) { Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { foreach (var id in ids) { try { //转换为实体对象  var ent = (Entity)id.GetObject(OpenMode.ForWrite); //删除  ent.Erase(); } catch (System.Exception ex) { AcadApp.ShowAlertDialog($\u0026#34;删除失败,原因 {ex.Message}\u0026#34;); } finally { } } tr.Commit(); } } } } 几何变换 矩阵  移动  Matrix3d.Displacement(Point3d.GetVectorTo(Point3d))\n 复制  Database.DeepCloneObjects(ObjectIdCollection identifiers, ObjectId id, IdMapping mapping, bool deferTranslation);\n 旋转  Matrix3d Rotation(double angle, Vector3d axis, Point3d center);\n 镜像  Matrix3d Mirroring(Line3d line(Point3d, Point3d));\n 缩放  Matrix3d Scaling(double scaleAll, Point3d center);\n变换 Entity.TransformBy(Matrix3d);\n/// \u0026lt;summary\u0026gt;  /// 移动对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;ME\u0026#34;)] public void MoveEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { //获取输入的两点  var result = ed.GetTwoPoints(out Point3d ptStart, out Point3d ptEnd); if (result) { //平移向量  var vector = ptEnd - ptStart; //矩阵,平移  var mt = Matrix3d.Displacement(vector); Database db = HostApplicationServices.WorkingDatabase; //开启事务处理  using (var tr = db.TransactionManager.StartTransaction()) { foreach (var id in ids) { //通过Id获取实体  var ent = (Entity)id.GetObject(OpenMode.ForWrite); //实体变换  ent.TransformBy(mt); //降为只读  ent.DowngradeOpen(); } tr.Commit(); } } } } /// \u0026lt;summary\u0026gt;  /// 复制对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;CE\u0026#34;)] public void CopyEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { //获取两点  var result = ed.GetTwoPoints(out Point3d ptStart, out Point3d ptEnd); if (result) { Database db = HostApplicationServices.WorkingDatabase; //  var map = new IdMapping(); ObjectIdCollection srcIds = new ObjectIdCollection(ids); //复制  db.DeepCloneObjects(srcIds, db.CurrentSpaceId, map, false); //平移  var vector = ptEnd.GetVectorTo(ptStart); var mt = Matrix3d.Displacement(vector); //源对象与复制对象字典  Dictionary\u0026lt;ObjectId, ObjectId\u0026gt; dictId = new Dictionary\u0026lt;ObjectId, ObjectId\u0026gt;(); using (var tr = db.TransactionManager.StartTransaction()) { foreach (var id in ids) { var idpair = map[id]; id.EntityTrans(mt); dictId.Add(idpair.Key, idpair.Value); } tr.Commit(); } } } } /// \u0026lt;summary\u0026gt;  /// 旋转对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;ROE\u0026#34;)] public void RotateEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { //获取旋转基点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定旋转中心点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { //旋转基点  var ptBase = ppr.Value; //获取旋转角度  var pao = new PromptAngleOptions(\u0026#34;\\n指定旋转角度\u0026#34;) { //设定旋转基点  BasePoint = ptBase, UseBasePoint = true }; var par = ed.GetAngle(pao); if (par.Status == PromptStatus.OK) { //旋转角度  var angle = par.Value; //矩阵,旋转  var mt = Matrix3d.Rotation(angle, Vector3d.ZAxis, ptBase); Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { //旋转对象  foreach (var id in ids) { id.EntityTrans(mt); } tr.Commit(); } } } } } /// \u0026lt;summary\u0026gt;  /// 镜像对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;MIE\u0026#34;)] public void MirrorEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { var result = ed.GetTwoPoints(out Point3d ptStart, out Point3d ptEnd); if (result) { //镜像线  var miLine = new Line3d(ptStart, ptEnd); //矩阵,镜像  var mt = Matrix3d.Mirroring(miLine); //提示关键字  var pko = new PromptKeywordOptions(\u0026#34;\\n是否删除源对象\u0026#34;); pko.Keywords.Add(\u0026#34;是\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;删除源对象(Y)\u0026#34;); pko.Keywords.Add(\u0026#34;否\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;保留源对象(N)\u0026#34;); pko.Keywords.Default = \u0026#34;否\u0026#34;; pko.AllowNone = true; //获取关键字  var pkr = ed.GetKeywords(pko); Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { //仅镜像  if (pkr.Status == PromptStatus.OK \u0026amp;\u0026amp; pkr.StringResult == \u0026#34;是\u0026#34;) { foreach (var id in ids) { id.EntityTrans(mt); } } //保留源对象镜像  else { foreach (var id in ids) { var ent = (Entity)id.GetObject(OpenMode.ForWrite); var entCopy = ent.GetTransformedCopy(mt); ent.DowngradeOpen(); var mirrorId = db.AddNewEntity(entCopy); } } tr.Commit(); } } } } /// \u0026lt;summary\u0026gt;  /// 缩放对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;SCE\u0026#34;)] public void ScaleEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { //提示缩放点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定缩放点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { //缩放点  var ptBase = ppr.Value; //提示缩放比例  var pdr = ed.GetDouble(new PromptDoubleOptions(\u0026#34;\\n指定缩放比例\u0026#34;)); if (pdr.Status == PromptStatus.OK) { //缩放比例  var scaleFactor = pdr.Value; //矩阵,缩放  var mt = Matrix3d.Scaling(scaleFactor, ptBase); Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { foreach (var id in ids) { id.EntityTrans(mt); } tr.Commit(); } } } } } /// \u0026lt;summary\u0026gt;  /// 绘制箭头  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;MAKEARROR\u0026#34;)] public void MakeArrow() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; //指定点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定箭头原点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { //点  var pt = ppr.Value; var pao = new PromptAngleOptions(\u0026#34;\\n指定角度\u0026#34;) { BasePoint = pt, UseBasePoint = true }; var par = ed.GetAngle(pao); if (par.Status == PromptStatus.OK) { //角度  var angle = par.Value; var pdr = ed.GetDouble(new PromptDoubleOptions(\u0026#34;\\n指定比例\u0026#34;)); if (pdr.Status == PromptStatus.OK) { //缩放比例  var scaleFactor = pdr.Value; //提示镜像  var pko = new PromptKeywordOptions(\u0026#34;\\n是否反向\u0026#34;); pko.Keywords.Add(\u0026#34;正向\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;正向(Y)\u0026#34;); pko.Keywords.Add(\u0026#34;反向\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;反向(N)\u0026#34;); pko.Keywords.Default = \u0026#34;正向\u0026#34;; pko.AllowNone = true; var pkr = ed.GetKeywords(pko); //箭头  Polyline pl = DrawArrow(); var mt = ed.CurrentUserCoordinateSystem; //矩阵,平移  mt *= Matrix3d.Displacement(pt.GetAsVector()); //旋转  mt *= Matrix3d.Rotation(angle, Vector3d.ZAxis, Point3d.Origin); ////对称可用旋转 pi  //if (pkr.Status == PromptStatus.OK \u0026amp;\u0026amp; pkr.StringResult == \u0026#34;反向\u0026#34;)  // mt *= Matrix3d.Rotation(Math.PI, Vector3d.ZAxis, Point3d.Origin);  //缩放  mt *= Matrix3d.Scaling(scaleFactor, Point3d.Origin); //反向,  if (pkr.Status == PromptStatus.OK \u0026amp;\u0026amp; pkr.StringResult == \u0026#34;反向\u0026#34;) { //镜像法向量  Vector3d vector = Vector3d.XAxis.RotateBy(Math.PI / 2, Vector3d.ZAxis); var miLine = new Line3d(Point3d.Origin, vector); mt *= Matrix3d.Mirroring(miLine); } //矩阵变换  pl.TransformBy(mt); Database db = HostApplicationServices.WorkingDatabase; //添加对象  db.AddNewEntity(pl); } } } } /// \u0026lt;summary\u0026gt;  /// 箭头图形  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;箭头多线段\u0026lt;/returns\u0026gt;  private static Polyline DrawArrow() { Polyline pl = new Polyline(); pl.AddVertexAt(0, new Point2d(0, 1), 0, 0, 0); pl.AddVertexAt(1, new Point2d(4, 0), 0, 0, 0); pl.AddVertexAt(2, new Point2d(0, -1), 0, 0, 0); pl.Closed = true; return pl; } 函数方法 /// \u0026lt;summary\u0026gt;  /// 获取输入的两点  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ed\u0026#34;\u0026gt;编辑器\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;ptStart\u0026#34;\u0026gt;起点\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;ptEnd\u0026#34;\u0026gt;终点\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;是否完成选择\u0026lt;/returns\u0026gt;  public static bool GetTwoPoints(this Editor ed, out Point3d ptStart, out Point3d ptEnd) { ptStart = Point3d.Origin; ptEnd = Point3d.Origin; var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定起点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { ptStart = ppr.Value; ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定终点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { ptEnd = ppr.Value; return true; } } return false; } /// \u0026lt;summary\u0026gt;  /// 获取选择的对象数组  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ed\u0026#34;\u0026gt;编辑器\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;prompt\u0026#34;\u0026gt;提示\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;对象Id组\u0026lt;/returns\u0026gt;  public static ObjectId[] GetSelectIds(this Editor ed, string prompt) { ObjectId[] ids = new ObjectId[0]; var pso = new PromptSelectionOptions(); pso.MessageForAdding = prompt; var psr = ed.GetSelection(pso); if (psr.Status == PromptStatus.OK) { ids = psr.Value.GetObjectIds(); } return ids; } /// \u0026lt;summary\u0026gt;  /// 对象变换  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;对象Id\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mt\u0026#34;\u0026gt;矩阵\u0026lt;/param\u0026gt;  public static void EntityTrans(this ObjectId id, Matrix3d mt) { var ent = (Entity)id.GetObject(OpenMode.ForWrite); ent.TransformBy(mt); ent.DowngradeOpen(); } ","date":"2021-02-08T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/new-project-3/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"选择集合与几何变换"},{"content":"输入输出 输入  获取点提示 PromptPointOptions() 获取点结果 ed.GetPoint() 状态 PromptStatus.OK  输出  输出信息 ed.WriteMessage()  /// \u0026lt;summary\u0026gt;  /// 提示选择点  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;PromptSelectPoint\u0026#34;)] public void PromptSelectPoint() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取点提示  var ppo = new PromptPointOptions(\u0026#34;\\n指定起点\u0026#34;); //获取点结果  var ppr = ed.GetPoint(ppo); //结果状态为OK  if (ppr.Status == PromptStatus.OK) { //起点  Point3d startPt = ppr.Value; ppo = new PromptPointOptions(\u0026#34;\\n指定终点\u0026#34;); ppr = ed.GetPoint(ppo); if (ppr.Status == PromptStatus.OK) { //终点  Point3d endPt = ppr.Value; //直线  Line line = new Line(startPt, endPt); //图形数据库  Database db = HostApplicationServices.WorkingDatabase; //添加直线  db.AddNewEntity(line); } else { ed.WriteMessage(\u0026#34;\\n取消画线\u0026#34;); } } else { ed.WriteMessage(\u0026#34;\\n取消画线\u0026#34;); } } /// \u0026lt;summary\u0026gt;  /// 连续绘制直线  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;AddLineMultiple\u0026#34;)] public void AddLineMultiple() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取起点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定起点\u0026#34;)); //结果状态为OK  if (ppr.Status == PromptStatus.OK) { //起点  var startPt = ppr.Value; //第一直线终点  ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定下一点\u0026#34;)); //图形数据库  Database db = HostApplicationServices.WorkingDatabase; //结果状态为OK  while (ppr.Status == PromptStatus.OK) { //终点  Point3d endPt = ppr.Value; //直线  Line line = new Line(startPt, endPt); //添加直线  db.AddNewEntity(line); //下一直线起点  startPt = endPt; //获取下一直线终点  ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定下一点\u0026#34;)); } } else { ed.WriteMessage(\u0026#34;\\n取消画线\u0026#34;); } } 几何图形 多线段  Polyline 平行四边形 矩形 正多边形  /// \u0026lt;summary\u0026gt;  /// 提示选择点  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DrawPolyLine\u0026#34;)] public void DrawPolyLine() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取起点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定点\u0026#34;)); //点列表  List\u0026lt;Point3d\u0026gt; pts = new List\u0026lt;Point3d\u0026gt;(); //结果状态为OK  while (ppr.Status == PromptStatus.OK) { //添加点  pts.Add(ppr.Value); //获取下一点  ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定下一点\u0026#34;)); } //点数大于1  if (pts.Count \u0026gt; 1) { //多线  Polyline pl = new Polyline(); //将点加入多线  for (int i = 0; i \u0026lt; pts.Count; i++) { Point3d pt = pts[i]; pl.AddVertexAt(i, new Point2d(pt.X, pt.Y), 0, 0, 0); } //图形数据库  Database db = HostApplicationServices.WorkingDatabase; //添加多线  db.AddNewEntity(pl); } else { ed.WriteMessage(\u0026#34;\\n获得的点少于2个，无法绘制。\u0026#34;); } } /// \u0026lt;summary\u0026gt;  /// 绘制平行四边形  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DrawParallelogram\u0026#34;)] public void DrawParallelogram() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取对象提示  var peo = new PromptEntityOptions(\u0026#34;\\n选择第一条直线\u0026#34;); //拒绝信息  peo.SetRejectMessage(\u0026#34;选择直线\u0026#34;); //只允许直线  peo.AddAllowedClass(typeof(Line), true); //获取对象结果  var per = ed.GetEntity(peo); //结果状态为OK  if (per.Status == PromptStatus.OK) { //图形数据库  Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { //直线1  var line1 = (Line)per.ObjectId.GetObject(OpenMode.ForRead); //长度大于0  if (line1 != null \u0026amp;\u0026amp; line1.Length \u0026gt; 0) { //获取点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { var pt = ppr.Value; //平行四边形点  List\u0026lt;Point3d\u0026gt; pts = new List\u0026lt;Point3d\u0026gt; { line1.StartPoint, line1.EndPoint, pt, pt - line1.Delta }; //创建多边形  db.CreatePolyline(pts); //删除原线  line1.UpgradeOpen(); line1.Erase(); } } else { ed.WriteMessage(\u0026#34;\\n直线长度过短。\u0026#34;); } tr.Commit(); } } } /// \u0026lt;summary\u0026gt;  /// 绘制矩形  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DrawRectangle\u0026#34;)] public void DrawRectangle() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取第一点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { var pt1 = ppr.Value; //获取角点  ppr = ed.GetCorner(new PromptPointOptions(\u0026#34;\\n指定角点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { var pt2 = ppr.Value; //矩形最大、最小点  Point2d maxPt = new Point2d(Math.Max(pt1.X, pt2.X), Math.Max(pt1.Y, pt2.Y)); Point2d minPt = new Point2d(Math.Min(pt1.X, pt2.X), Math.Min(pt1.Y, pt2.Y)); //边界点  List\u0026lt;Point2d\u0026gt; pts2d = new List\u0026lt;Point2d\u0026gt; { minPt, new Point2d(maxPt.X, minPt.Y), maxPt, new Point2d(minPt.X, maxPt.Y), }; Database db = HostApplicationServices.WorkingDatabase; //绘制矩形  db.CreatePolyline(pts2d); } } } /// \u0026lt;summary\u0026gt;  /// 绘制正多边形  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DrawRegularPolygon\u0026#34;)] public void DrawRegularPolygon() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定正多边形中心\u0026#34;)); if (ppr.Status != PromptStatus.OK) return; //获取第二点  var pt1 = ppr.Value; ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定正多边形角点\u0026#34;)); if (ppr.Status != PromptStatus.OK) return; var pt2 = ppr.Value; //长度  var distance = pt2.DistanceTo(pt1); if (distance == 0) return; //多边形数量  var pio = new PromptIntegerOptions(\u0026#34;\\n输入多边形边数\u0026#34;); var pir = ed.GetInteger(pio); if (pir.Status != PromptStatus.OK) return; int sideNum = pir.Value; //变数不小于3  if (sideNum \u0026lt; 3) return; List\u0026lt;Point2d\u0026gt; pts2d = new List\u0026lt;Point2d\u0026gt;(); //初始角度  var angle = (pt2 - pt1).GetAngleTo(Vector3d.XAxis); //负角度  if (pt2.Y \u0026lt; pt1.Y) angle = -angle; //初始点  for (int i = 0; i \u0026lt; sideNum; i++) { //相对向量  var vector2d = new Vector2d(Math.Cos(angle), Math.Sin(angle)) * distance; //计算点  var pt = pt1.Convert2d() + vector2d; pts2d.Add(pt); //角度增量  angle += Math.PI * 2 / sideNum; } Database db = HostApplicationServices.WorkingDatabase; //添加多边形  db.CreatePolyline(pts2d); } 其他函数 /// \u0026lt;summary\u0026gt;  /// 绘制多线段  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;db\u0026#34;\u0026gt;图形数据库\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;pts2d\u0026#34;\u0026gt;2维点集合\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;closed\u0026#34;\u0026gt;闭合\u0026lt;/param\u0026gt;  public static ObjectId CreatePolyline(this Database db, List\u0026lt;Point2d\u0026gt; pts2d, bool closed = true) { //点数过少返回空  if (pts2d.Count \u0026lt; 2) return ObjectId.Null; //多线  Polyline pl = new Polyline(); //将点加入多线  for (int i = 0; i \u0026lt; pts2d.Count; i++) pl.AddVertexAt(i, pts2d[i], 0, 0, 0); //闭合  pl.Closed = closed; //添加多线  return db.AddNewEntity(pl)[0]; } /// \u0026lt;summary\u0026gt;  /// 绘制多线段  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;db\u0026#34;\u0026gt;图形数据库\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;pts2d\u0026#34;\u0026gt;3d点集合\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;closed\u0026#34;\u0026gt;闭合\u0026lt;/param\u0026gt;  public static ObjectId CreatePolyline(this Database db, List\u0026lt;Point3d\u0026gt; pts, bool closed = true) { //2d点集合  var pts2d = new List\u0026lt;Point2d\u0026gt;(); for (int i = 0; i \u0026lt; pts.Count; i++) pts2d.Add(pts[i].Convert2d()); //var pts2d = pts.Select(p =\u0026gt; new Point2d(p.X, p.Y)).ToList();  return db.CreatePolyline(pts2d, closed); } /// \u0026lt;summary\u0026gt;  /// 3d坐标转2d  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pt\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static Point2d Convert2d(this Point3d pt) { Document doc = AcadApp.DocumentManager.MdiActiveDocument; Editor ed = doc.Editor; return pt.Convert2d(ed.GetPlane()); } /// \u0026lt;summary\u0026gt;  /// 获取法向量平面  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ed\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static Plane GetPlane(this Editor ed) { return new Plane(Point3d.Origin, ed.GetNormal()); } /// \u0026lt;summary\u0026gt;  /// 当前坐标系法向量  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ed\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static Vector3d GetNormal(this Editor ed) { return Vector3d.ZAxis.TransformBy(ed.CurrentUserCoordinateSystem); } ","date":"2021-02-01T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/new-project-2/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"用户交互与几何图形"},{"content":"变化  2020年时光流逝，这一年有很多变化和新的开始，需要回忆记录下。\n 年初在家，是我这些年在家过的时间最长的一个年，过年变得淡然起来。感受到随着年岁增长，家人需要陪伴、身体需要修养。一直到三月初才从老家回到昆山，见到妻儿。\n 回到办公室，当时还是很茫然的，不知道这一年是否又像之前一样重复无所成长。刚开始在推用协奕软件方案工具，我做一些资料，过程中大家提了一些问题，也只能在我会的基础上修修改改。在某一个中午，于工召集陈总、骆工和我在会议室讨论图纸，说了一些参照、视口、区域覆盖的一些内容，并没有什么结论，只是证明了一些事情。骆工建议去了解设计师的需求，想着做一个好用的功能去实现。\n 四月中旬开始，从头开始看邵工写的剖立面功能（以前不敢深入，怕各种方法我会找不到方向）到逐渐理解。网上找资料，在基础上新增一些改动，在五一前终于有个初始的新剖立面给建筑设计师用，但当时存在许多错误以及不稳定。五月我去了一趟杭州和小左游了西湖，受到了一些肯定，坚定了要做下去的想法。重新开始看了AutoCAD开发基础、C#图解教程这些一直看不完的书（到现在还没看完）；新买了一些书，一本何教授写的《几何计算》给了我方向和方法，重新了解向量、直线方程式（再也到不学校时期的证明解题水平），给了更多可能。期间张莉一直给予我很多支持和配合，不断新增了一些小功能，过程中让自己的技能水平有了一点成长，才知道自已一直是门槛水平。\n 逆风——花园精灵\n  因为一些变动，我需要一些安静环境。七月开始我在昆山办公，有了一定自由，我要去努力实现2020年的想法，从一张已知的平面图纸绘制配套图纸。截取-\u0026gt;标注-\u0026gt;标高-\u0026gt;剖立面-\u0026gt;图纸。截取就是从平面图纸局部内容，从复制开始，分类、打断、轴线轴号、剪切。从AutoCAD支持的方法不断尝试，创建、处理一些看似存在的过程，不断前行。\n\r图1.gif\r\n 设计时用了天正，觉得简单方便，便于批量修改，哪里能用就用。二次开发中遇到天正对象就是个未知，什么也找不到，什么也用不上，希望天正内容通通分解。要想标注只能依靠AutoCAD的标注，仔细看书标注就是两点一线这么简单。图纸上无外乎是在正交方向的标注，那么只要会画线就可以探索图形去标注，原来简单的对象如此强大。\n\r图2.gif\r\n 对于天正的无知，会和设计师画图方法脱离，重复的分解产生更多的误差。在八月的某天一次调试中发现了天正的秘密，在邵工的提示下找到了认知的方法，终于重新认识了天正对象，让后续的功能准确识图建立了良好基础。之后空余时间做了一个新的给排水套管工具，从设计师角度填入一些必要设计参数，识别图纸按设计需求添加套管、记录信息、添加代号、生成表格、添加大样，用一个窗口解决一张图的事。\n\r图3.gif\r\n 标高是生成剖立面关键的参数，从设计师的口中获得了初始的标高系，剖切符号是图纸转向另外一个平面坐标系的关键节点。形状由几何元素组成，相互约束结构成图，从画法几何角度去计算图形，实际是一场数据交换过程。通过设置标高、添加剖切号、平面识别、图形转换、重建图形，能相对完整的去表达一个建筑详图。\n\r图4.gif\r\n 也可以用新的方法解决以前的问题。\n\r图5.gif\r\n2020更新\n协奕软件更新\n 开始  在这些实验过程中也让请张莉在图纸中不断试错，时不时出现未知的问题，有的只能让它Catch Continue。需求、想象是多种多样的，我还需要耐心去学习，还需要时间去成长。下半年来最多的感觉是时间不够，不够我去学习，不够我去尝试，不够去解决问题，不够去应对变化，不够我去生活。我还有很多学习在收藏夹，还有很多可能要去尝试，还有很多问题要去解决，只希望时间能等等我，不要有过多压力去面对生活。\n 飞机云——《起风了》\n  这一年要感谢的人很多，有些来不及说声谢谢。还是要感谢下老板，对我的支持。还有很多期待，希望有一个好的开始去探索2021年的未知。\n动态的可能\n李元宏\n2021.01.15\n","date":"2021-01-15T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/2020summary/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"2020年记忆"},{"content":"2020.9.27更新  增加平面截取功能。绘制截取框直接对平面图形（包含块参照），生成截取框内图形，裁剪边界图形，并对裁剪框指定范围内部分设计图形进行标注。\n\r\n功能更新如下：  绘制截取框； 裁剪截取框； 截取平面； 设置截面参数；  \r\n功能说明  绘制截取框：指定两点添加截取框（图层：JA-索引，线型：DASH，线宽：100，圆角可设置）。 裁剪截取框：指定两点裁剪已存在的截取框（仅支持单段裁剪），生成新的截取框（裁剪位置处目前非圆角）。 截取平面：选择已添加的截取框，指定位置生成截面内容，生成的截面遵循一下规则：   3.1\t截取的人防门及文字按截取比例（可设置）设置，天正的内容需用天正的比例修改。 3.2\t截取生成的内容包含截取框内对象，截取边界打断曲线对象（包括直线、多线段、圆、天正墙体等），对块图形剪切。 3.3\t截取内容会忽略删除图层（可设置）的对象，对位于底图图层（可设置）的图块内对象再次截取。 3.4\t轴线识别参数：在模型空间或底图图块，直线、DOTE线型，轴号识别参数：图块（块名：_AXISO）、圆或者天正图名索引，在轴线延长范围内。 3.5\t截取内容下方会生成图名，并与截取框引注向关联。图名命名以截取的房间名称最多次数（可设置）的为准。 3.6\t对与折断线标注探索范围内对象进行标注，目前支持的标注对象包括天正墙体、柱子、门洞，我院建筑图层下的混凝土墙、砖墙、柱子、轴线。  \r\n参数设置   4.1\t截面间距：设置两个连续截面上下距离； 4.2\t详图比例：生成的截面内容的比例，主要与文字、门窗型号有关。； 4.3\t轴号距离：轴线端点与折断线的距离； 4.4\t折断超出：相交的折断线超出的尺寸； 4.5\t标注探索：相对折断线范围内指定类型对象（一般垂直折断线）进行标注； 4.6\t截取圆角：设置截取框圆角大小； 4.7\t第二尺寸：标注的第二道尺寸线与第三道尺寸距离； 4.8\t第三尺寸：标注的第三道尺寸线与折断线距离。 4.9\t底图内容：该图层的图块会块内对象再次截取，可选择对象按图层添加。 4.10\t删除内容：忽略该图层对象，不会被截取，可选择对象按图层添加。 4.11\t图名设置：根据列表内容命名图名，图名是以房间名称出现最多的名称命名，可右键该列表，增加、修改、删除内容。   平面截取是剖立面功能的一部分，相对之前支持了天正的对象，后续还会改进协奕标注、新剖立面等功能，使其完善更加一体化。也需要大家多试用，提出意见。让画图不要太难，不用太累。\n李元宏\n2020.9.27\n 2020.7.1更新  最近在做详图标注，可对详图平面进行标注。 \r\n功能更新如下：  矩形标注； 正交标注； 绘制矩形框、正交线，进行框线标注； 多点标注； 合并标注。  \r\n功能说明  点击图库工具中的协奕标注按钮，出现添加标注窗口。   1.1\t预览图说明：黄色线为标注边框线，灰白色为探索边界线，绿色为尺寸标注。探索边界线内外距离标注边框线分别为S/2，探索边界线内外相距为S（探索边界）；尺寸标注与标注边框线距离为D（标注偏移）； 1.2\t可标注对象：第三道尺寸线：对符合图层标准的混凝土墙、砖墙、柱子、轴线，且垂直于边框线的图形标注；第二道尺寸线：对与边框线垂直的轴线标注。 1.3\t尺寸线数量说明：一道尺寸，仅包含第三道尺寸线；两道尺寸，包含第三道尺寸线和第二道尺寸线。矩形或多线段（点数\u0026gt;2）标注边框线，按尺寸线数量设置为准。正交或直线（多线段点数=2）标注边框线按一道线尺寸标注。 1.4\t尺寸线方向说明：默认方向，尺寸线接近竖直，竖直(Y轴正向)向右标注，尺寸线接近水平，水平(X轴正向)向下标注；右侧方向，始终以标注边框线终点方向右标注。矩形或多线段（点数大于2）以图形的逆时针方向，向右标注。正交或直线（多线段点数为2）以方向设置为准。  探索边界与尺寸偏移设置   2.1\t设置探索边界S尺寸，即标注边框线向内向外各S/2距离查找可标注对象。 2.2\t设置尺寸偏移D尺寸，即标注边框线向指定方向偏移D距离绘制尺寸标注。  矩形标注：指定两点为矩形对角点，以此矩形按照探索四条边框线可标注对象，以尺寸线数量设置，进行默认向右标注。 正交标注：指定两点以其长边方向，以两短边中点为端点的正交线，探索此边框线可标注对象，以尺寸线方向设置，进行一道尺寸标注。 线框标注   5.1\t矩形框：指定两点，绘制一个尺寸标注图层（JA-尺寸标注）线宽100的矩形框； 5.2\t正交线：指定两点，绘制一个以长边为方向，以短边中点为端点的正交线，图层为尺寸标注图层（JA-尺寸标注）线宽100。 5.3\t框线标注：选择图层为尺寸标注图层（JA-尺寸标注）的直线或多线段（可自行绘制，不闭合的多线段，目前只需图层符合要去即可），按照已设定的探索边界、标注偏移、尺寸线数量、尺寸线方向，进行尺寸标注。非矩形多边形按其最大范围矩形的四边标注。  其他标注   6.1\t点点标注：点选需要标注的点，选点结束后点击空格或者回车，再点击标注线位置，如果点选内容大致方向（水平或竖直），绘制通过标注线位置同方向标注（水平或竖直标注）；也可以在选点结束后输入S选项，再选择一个已有的转角标注，绘制一个与该转角标注结合的同方向标注。 6.2\t合并标注：选择多个的尺寸标注（一般是需要合并的小标注），再选择一个同方向的定位标注（一般是需要保留的大标注），自动删除前者所有标注，与定位标注结合的新标注内容。 现在的协奕标注功能主要的功能是对详图平面的标注和剖面尺寸的合并，大家可以合理的运用，可以尝试设置不同的探索边界、不同的标注偏移尺寸（比如0），不同的正交标注方向，去熟悉标注的用法，有一定的了解后，就可以随心绘制边框线，让协奕标注来执行。目前也处在测试阶段，可能对于非正交角度、UCS情况还未完全支持，也请大家多用，多提问题，把功能做好更有利于大家的设计绘图。  李元宏\n2020.7.1\n 2020.6.17更新  最近新做了 临战封堵 统计汇总功能，耽误了一些时间。目前的更新如下：\n目前的功能更新如下：  设置人防门的封堵属性； 标注平面封堵； 生成封堵表； 生成项目概况，添加其他专业封堵表； 平战转换工作量表（由封堵表重生成）； 维护手册人防门分单元统计； 修复剖立面工具个别问题。  \r \r 功能说明 使用临战封堵时，人防门图块需是服务器中人防门最新版，可用添加人防门自动更新人防门图块，或者剖立面中的更新图块按钮。\n 封堵类型设置（普通，出入口，单元间）   1.1\t在人防门添加时，可以在添加界面中下位置，直接选择封堵的类型； \r 1.2\t人防门添加后，通过图块夹点或特性修改门的封堵属性； \r 1.3\t点击临战封堵命令按钮（命令WARBLOCK），在窗口中选择封堵类型，点击设置封堵按钮批量设置同类型封堵  \r\r\n封堵标注   2.1\t点击封堵标注按钮，对所有单元间、出入口封堵标注，所有类型序号以当前设置的序号为起始，图号以当前图号为准。出入口封堵会添加门的闭合线，数字序号1，2……；单元间一道门，序号为T1，T2……；单元间一框两门，序号为L1，L2……。 2.2\t封堵索引添加后，点击设置序号，选择单个索引设置当前序号值，设置成功一个后序号加1，可连续设置；点击设置图号，选择多个索引设置当前图号。 2.3\t若封堵类型有修改，可再次执行封堵标注，选中封堵与之前标注，会自动将原有内容做相应修改。   注意：封堵索引不可复制，复制的索引可能会被二次封堵标注时删除。\n临战封堵表   3.1\t输入项目编号，点击项目概况生成项目概况表，同时默认附加5个A4可打印图框（用输出PDF命令）。 3.2\t点击临战封堵表，选择封堵和索引以及全部相应轴线轴号内容，生成封堵表。 注意：如封堵和引注不是封堵标注按钮的生成结果，则不会被匹配生成相关数据。轴线轴号必须符合我院当前图层标准；轴号支持天正索引符号、块、文字三种状态；轴线轴号在当前模型空间、块、参照均支持。 3.3\t点击其他专业，添加与临战平战转换工程量概况表其他专业内容。 3.4\t三份表格可以按上下顺序连接起来，超过A4边框的部分，可以在表格下方点击蓝色方向夹点向上推动，自动断开表格。表格默认间距是10000，可以通过表格特性调整间距去适应边框，或者调整边框适应表格。 注意：表格默认打断方向是下，手动高度为是。 3.5\t表格内容可以双击表格单元进行编辑，也可点中单元格在特性内填写；CAD表格支持添加、删除表格行，合并单元格，单元格设置字体样式，多个内容复制等；  平战转换表   4.1\t点击平战转换表按钮，选择之前生成的临战封堵表会重生成平战转换表。生成的对应详图号目前是个圆圈，可以双击在出现的窗口点确定，输入对应详图号。  维护手册人防门信息统计，执行定位表（POSITIONTABLE）命令,选择定位内容：人防门，点击单元图层选择按钮，找到单元图层名称，点击确定，选择人防门、轴线轴号，生成相应维护手册内容。   注意：生成手册信息之前，需用独立的图层创建划分单元的区域（闭合多线段），目前支持按照单元图层的颜色号为单元名称（如1号色，对应防护单元1）。\n剖立面工具修改：新增连续填充按钮，支持生成的多个剖立面填充，若后期有新增墙体还是需要用逐个填充；若剖立面缺少轴线则会弹出提示停止绘制，只有一道轴线时，只标注第三道尺寸线；修复一框两门的绘制错误。   从设计平面图到施工图其中还有很多事可以做，需要时间，需要配合。做出来了需要有人用，需要提意见，工具才能越做越好，才能发挥应用的实效。还是感谢大家支持，希望未来越来越好。\n李元宏\n2020.6.17\n2020.5.21更新  计划制作多专业的设计平面图到设计施工图的辅助绘图工具，主要阶段为平面截取，平面标注，设置标高（剖切号、房间标高），生成剖立面，修改整理等功能。\n 目前基本完成是设置标高，生成剖立面（建筑）。\n\r \r\n本次修改相对上一版本主要新增支持的对象有：  添加剖切号，独立设置标高，剖切号排序，支持折线剖切； 添加房间标高功能，指定房间标高，避让其他文字； 读取剖切号标高，对剖切号、房间应用标高； 更新平面图块； 设置标准图层； 剖面标高复制，复核； 支持天正、圆、块方式的轴号。 支持剖立面图中洞口，人防门活门槛标注。  \r \r\n 修改内容较多，主要按设计人员意见修改剖面图内容，以至更接近施工图内容。\n\r \r\n注意事项  当前功能的对象以我院图层标准为基础，当图形未正常显示时可用【图层设置】检查一下图层是否准确。 本次修改和之前图块有许多不同，因此需要使用【更新图块】功能，执行一次更新图块会将剖立面中用到的图块更新（会导致部分属性图块文字变化）。 剖立面以标高系为基础，使用【标高管理】设定标高，在设置标高后在当前窗口中，【添加剖切号】，【添加标高】。不同的标高系，可以通过【读取标高】获取及【应用标高】修改已经添加的剖切号和房间标高。 竖向尺寸不满足要求时，错误厚度会红色背景显示。所有房间名称文字会以选择的基础标高标注，可以选择或填入指定房间名称（用 , 号分隔），凡是包含指定房间名称的会以浮动标高标注。如果有两行房间名称，首行房间名称会被忽略，遇到其他文字标高会自动下移。若要重新生成或修改已有房间标高，需在【添加标高】时同时选中房间名称和原标高。 剖切号数字左右不一致时会以【SECTION1】的数值默认修改，如果剖切号有重复不会自动生成剖立面，可以用【标高管理】界面中【序号重排】按钮对剖切号排序。 剖切号与之前版本块名不一致，需使用【标高管理】中【添加剖切号】。 不确定轴号模式可以用选择按钮，选择一下轴号，再去生成剖立面。 其他支持剖立面的图形可以从图库工具中调用，涉及到高度的图块，需在生成剖立面之前设置（图库添加时，或对象特性自定义中修改）。 目前主要支持的对象基本是CAD图形，生成剖立面前天正图纸需要转T3或天正分解。  使用方法  执行命令：点击新剖立面命令 0 按钮  \r\n剖立面主界面——前期设置    2.1\t如果当前图中图块非最新，点击更新图块 ① 按钮。 \r\n  2.2\t如果当前图中图层非我院标准，点击图层设置 ② 按钮，在设置图层界面中找到指定图层名称，点击 ＠ 按钮，选择图形对象，如果当前图纸中不存在该标准图层，会将对象图层改为标准图层，如果已存在标准图层，会将该图中该图层的所有对象改到标准图层。 \r\n  2.3.\t设置标高，添加剖切号，添加房间标高，点击 ③ 按钮。\n  标高管理界面    3.1.\t标高数值可在竖向尺寸区域内填写，可填写的标高有：A覆土面标高，B底板面标高，D底板面标高，可填写的厚度有：B1顶板厚，C1面层厚，D1面层厚；其余标高、厚度通过计算显示（覆土厚度\u0026lt;0mm或建筑层高2000mm会显示红色背景）。每个标高有其代号在房间标高块中对应。 \r\n  3.2\t房间标高\n   3.2.1\t选择默认房间基础标高 ④ 下拉框，指定房间也会以此为基础标高与浮动值计算； 3.2.2\t可连续选择平面内房间名称（CAD单行文字） ⑤ 按钮，或者直接在指定房间下用英文逗号(,)分隔房间名称，浮动值框内填写与基础标高差异高度。 3.2.3\t点击添加标高 ⑥ 按钮，选择需要添加标高的详图平面，会自动在所有房间名称下面，添加标高。指定房间标高以浮动标高值为准，其他房间以基础标高为准，自动避让其他文字，若存在多行房间名称上下放置，以下行文字内容及位置为准。房间标高添加规则，与房间名称和已添加的标高有关：1如果选择包含房间名称及多个旧原标高（复制的情况）会保留离房间名称最近的一个其余删除，2如果勾选允许修改，会将最新的标高数据修改旧标高，3如果不勾选允许修改，旧标高不做任何修改。   3.3\t剖切号   3.3.1.\t可以剖切号序号输入数值，添加剖切号或序号重排时以此序号为准。 3.3.2.\t剖切号样式包含直线、折线。 3.3.3.\t添加剖切号点击 ⑦ 按钮，选择剖切号的起始点与终点，剖切号会自动按照两点组成的矩形，长边为剖切线长，短边为剖切线深度，且剖切线所在起始点，深度指向终点。剖切号深度宜只包含可见对象的深度，且需要至少包含可见对象的一条边。 3.3.4.\t需要排序剖切线编号点击 ⑧ 按钮，默认以剖切号序号为起始号，再选择其他剖切号连续编号，或者选择一个剖切号序号为起始号，再选择其他剖切号排序。   3.4.\t标高的读取与应用   3.4.1.\t点击 ⑨ 按钮，可以从已添加的剖切号中读取标高，自动填写竖向尺寸数值。 3.4.2.\t点击 ⑩ 按钮，选择剖切号或者房间标高，以当前竖向标高数值应用到图形中。  剖立面主界面——生成剖立面   4.1.\t选择专业 11 按钮，目前支持建筑专业。 \r 4.2.\t输入剖面转换参数（一般小距离墙，如悬板活门时需要设置）   4.2.1.\t剖面间距：生成的多个剖面图之间的水平距离。 4.2.2.\t最小墙厚：平面中两段墙线（直线）间距小于该尺寸，不会在剖面中画墙。 4.2.3.\t最大墙厚：平面中两段墙线（直线）间距大于该尺寸，不会在剖面中画墙。 4.2.4.\t最小墙长：平面中的墙线（直线）长度小于该尺寸，不会在剖面中画墙。 4.2.5.\t最大挡梁：平面中上挡梁距离人防门距离大于该尺寸，不会再剖面中画上挡梁。 4.2.6.\t井盖厚：剖面中的集水井井盖厚度。   4.3.\t轴号模式支持天正、圆、块三种模式，不确定时可以用 12 按钮选择轴号。 4.4.\t点击 13 按钮之后选择剖切号，生成以该剖切号设定的标高的剖面。   4.4.1.\t若剖切号有重复会退出，请执行 ⑧ 按钮对剖切号排序； 4.4.2.\t若剖切对象中包含旧版图块（本版之前的图块），请执行一次 ① 按钮更新图块； 4.4.3.\t若图纸中缺少指定对象，如墙体、轴线、柱子请执行 ② 按钮，修改对象图层到标准图层； 4.4.4.\t若缺少轴号，请检查轴号图层或执行 12 按钮更换模式。   4.5.\t点击 14 按钮，支持对混凝土墙体和砖墙填充，可连续执行。 4.6.\t在已生成的剖面上，点击 15 按钮，可以对已有标高复制自动标注标高，以及通过以一个标高为基础复核并修改其他所选标高。   在制作过程中感谢@张莉、@陆玮玮、@杜一晗、@方亦驰、@王睿的帮助，@汤晓靓的意见，@于永虹的支持。还有很多的问题，需要大家提出和共同解决，还有许多未知的可能，需要细心的雕刻。\n技术研究室\n2020.5.21\n2020.5.7更新 更新内容：  人防门剖立面吊钩及标注； 上挡墙及标注； 人防门剖面标注。  注意事项：  上挡墙需在详图平面内标识（图层：JA看线，距人防门距离小于500mm时）。\n技术研究室\n2020.5.7\n剖立面功能更新说明  为了有效提高建筑设计施工图绘制效率，在原有剖立面功能上进行功能改进更新。\n 新版剖立面支持符合我院新的建筑图层标准的CAD图纸（天正T3版本），并支持协奕图库工具设计图块，支持多个剖面连续生成。\n\r\n主要支持的平面转剖立面的图形有：  钢筋混凝土墙、砖墙、柱子； 人防门、防火门、一框两门； 集水井、竖井； 轴线、轴号。  \r\n生成的剖立面图具有：  覆土、顶板、面层、底板； 水平及竖向第二、第三道尺寸标注； 标高标注、折断线、图名； 墙体填充。  \r\n 剖立面命令与原剖立面命令一致，可在原命令按钮之后选择新版或者输入N开始使用。\n注意事项：  需采用设计图库中的 建筑——详图 中的剖切号图块添加到详图平面中作为剖切号，剖切方向末端有灰色框线为剖切深度，需要把剖切的内容包含在剖切深度内，减少非剖切内容被包含，可复制剖切号，支持自动排序。目前仅支持矩形范围剖切，后期更新可支持多边形范围剖切。 目前暂时支持天正转T3图纸的生成，后期改进可能支持部分天正图形。 平面中的图块必须是设计图库中最新的图块，如果不是程序可自动更新设计图块以支持生成。 支持集水井深度自定义，需要在集水井图块的属性面板中自定义——深度，输入深度数值。 剖立面主界面中，需要设置支持的最大墙厚、最小墙厚、最小墙长数值。最大、最小墙厚数值定义：若两段垂直于剖切线的墙体间距大于最大墙厚或小于最小墙厚，会被忽略。最小墙长定义：如果垂直于剖切线的墙体线段长度大小于最小墙长会被忽略。 填充墙体也可输入XYHATCH命令，指定墙体类型进行连续填充。 后续计划支持的内容有吊钩、门洞、上挡墙、详图平面尺寸标注、剖切符号添加、详图平面截取等功能。因本版本初次发布，还存在一些错误或不完善，具体设计平面需有设计人员校核后使用，也希望设计人员能够提供建议帮助和支持，谢谢。  上海结建民防建筑设计有限公司\n技术研究室\n2020.4.29\n","date":"2021-01-15T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/2020update/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"2020的更新"},{"content":"一个新项目 Visual Studio 1. 安装  登陆 语言  2. 创建新项目  解决方案 项目 项  3. HelloWorld  using namespace class  4. 工具  代码片段  5. 调试  断点 条件 监视（自动窗口/局部变量）  AutoCAD 1. 注册 2. 命令  line/point/vector/circle copy/move/scale/mirror block/dim/text  ObjectARX 1. 类库(.Net Framework)  4.5.2 AcDbMgd AcMgd  2. HelloWord  Editor Application  3. 调试  设为启动项 启动外部程序 NetLoad  4. Line  F12 \r  /// \u0026lt;summary\u0026gt;  /// 新建直线(newline)  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;newline\u0026#34;)] public void NewLine() { //定义直线，起点：100, 100, 0；终点：300, 200, 0  Line line = new Line(new Point3d(100, 100, 0), new Point3d(300, 200, 0)); //打开当前图形数据库  Database db = HostApplicationServices.WorkingDatabase; //启动事务处理器  using (Transaction tr = db.TransactionManager.StartTransaction()) { //打开块表  BlockTable bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead); //打开块表记录(可写方式)  BlockTableRecord btr = (BlockTableRecord)tr.GetObject(bt[BlockTableRecord.ModelSpace], OpenMode.ForWrite); //添加对象（直线）到块表记录  btr.AppendEntity(line); //块表记录降为只读  btr.DowngradeOpen(); //更新数据  tr.AddNewlyCreatedDBObject(line, true); //提交事务处理  tr.Commit(); } }  封装  /// \u0026lt;summary\u0026gt;  /// 实体工具组  /// \u0026lt;/summary\u0026gt;  public static class EntityTools { /// \u0026lt;summary\u0026gt;  /// 在图形数据库中添加对象  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;db\u0026#34;\u0026gt;图形数据库\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;entitys\u0026#34;\u0026gt;图形组\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;对象Id组\u0026lt;/returns\u0026gt;  public static ObjectId[] AddNewEntity(this Database db, params Entity[] entitys) { //对象Id组  ObjectId[] ids = new ObjectId[entitys.Length]; //启动事务处理器  using (Transaction tr = db.TransactionManager.StartTransaction()) { //打开块表  BlockTable bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead); //打开块表记录(可写方式)  BlockTableRecord btr = (BlockTableRecord)tr.GetObject(bt[BlockTableRecord.ModelSpace], OpenMode.ForWrite); //连续添加图形  for (int i = 0; i \u0026lt; entitys.Length; i++) { //添加对象（直线）到块表记录  ids[i] = btr.AppendEntity(entitys[i]); //更新数据  tr.AddNewlyCreatedDBObject(entitys[i], true); } //块表记录降为只读  btr.DowngradeOpen(); //提交事务处理  tr.Commit(); } //返回对象Id组  return ids; } } 几何计算 直线方程式  Ax + By + C = 0  /// \u0026lt;summary\u0026gt;  /// 直线方程式（Ax + By + C = 0）  /// \u0026lt;/summary\u0026gt;  public struct LineEquation { public double A; public double B; public double C; internal LineEquation(double a = 1, double b = -1, double c = 0) { A = a; B = b; C = c; } }  直线转直线方程式  /// \u0026lt;summary\u0026gt;  /// 两点转直线方程  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pt1\u0026#34;\u0026gt;点1\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;pt2\u0026#34;\u0026gt;点2\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;le\u0026#34;\u0026gt;直线方程式\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;两点重合输出false\u0026lt;/returns\u0026gt;  public static bool Lpp(Point3d pt1, Point3d pt2, out LineEquation le) { le = new LineEquation(1, 0, -pt1.X); var a = pt2.Y - pt1.Y; var b = pt1.X - pt2.X; var c = Math.Sqrt(a * a + b * b); if (c \u0026gt; 0) { le.A = a / c; le.B = b / c; le.C = -le.A * pt1.X - le.B * pt1.Y; return true; } else return false; } /// \u0026lt;summary\u0026gt;  /// 直线转直线方程  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;line\u0026#34;\u0026gt;直线\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;le\u0026#34;\u0026gt;直线方程式\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;直线长度为0输出false\u0026lt;/returns\u0026gt;  public static bool Lel(this LineSegment3d line, out LineEquation le) { return Lpp(line.StartPoint, line.EndPoint, out le); } 直线方程式计算  垂足  /// \u0026lt;summary\u0026gt;  /// 点到直线方程式垂足  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pt\u0026#34;\u0026gt;点\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;le\u0026#34;\u0026gt;直线方程式\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;垂足\u0026lt;/returns\u0026gt;  public static Point3d Ppln(this Point3d pt, LineEquation le) { double d = le.A * pt.X + le.B * pt.Y + le.C; return new Point3d(pt.X - d * le.A, pt.Y - d * le.B, 0); } ","date":"2021-01-09T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/new-project/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"一个新项目"},{"content":"向量投影问题  在一个二维坐标系中一条线段Line_ab，起终点分别为A(100,100)，B(300,200)，一条线段Line_cd，起终点分别为C(100,200)，D(150,225)。 \r已知条件\r 计算Line_cd投影到Line_ab上的线段 ( 如下图所示Line_ef )。 \r计算投影线段\r  \r\n","date":"2021-01-06T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/geomath-problem1/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"几何算法问题1"},{"content":"概况 图形计算编程主要分两部分内容 1. 算法  几何计算 数据运算  2. 编程  C# 方法 AutoCAD 接口  对于平面设计（建筑行业）主要对象是二维图形，用到的几何计算主要与点、线、框的计算方法；数据运算主要是按照功能需求，对已有的数据准确有效处理。 因为平面设计主要使用 AutoCAD 软件开发，而 AutoCAD 支持 .net 开发，其中 C# 语言易于上手，相关功能资料齐全，易于软件开发使用。\n学习资料 1. 几何计算  《几何计算》 何援军 著，该书讲解二维、三维图形基础计算方法，并用 C++ 给出代码示例，是一本很好的几何计算入门书籍。该书没有电子版，可在京东购买。  2. C#  《C#图解教程》（第4版） 该书介绍了 C# 语言特性，用一些图示方法展示基本原理，适合打好编程语言基础。 《C#本质论》（第4版） 适合扩展提高。 C#入门到精通 这是一套比较全面的视频资料，不过需要很多时间浏览，适合看书遇到疑问时找视频相关内容了解。 C# 菜鸟教程 简明的语言教程网站，适合临时找内容。 C# 官方文档 最全最专业的官方文档，适合深入研究。  3. 算法  《算法》（第4版） 一本专业的算法书籍，让计算简单而有效。 算法第四版 - Course课程 这是上面这本书的视频教程。 Leetcode 题解 Leetcode 是一个专门是算法解题网站，这是一个挑选了常用算法的网站，可以学习这些算法用于解决可能的问题。  4. AutoCAD 二次开发  《Auto CAD VBA\u0026amp;VB.NET开发》 增洪飞等 著，一本适合入门，基本了解 AutoCAD 功能的各个方面。 《深入浅出AutoCAD.NET二次开发》 李冠亿 著，根据 AutoCAD.NET 开发接口，介绍各种基础方法。 CAD二次开发视频C#语言 李小科录制，从编程、对象的角度去实现计算、开发等功能，相对容易上手。 AutoCAD 2018 官方文档 官方专业文档，适合深入研究。 AutoCAD 官方博客 适合了解 AutoCAD 最新方法或功能。  需要准备的软件 1. Visual Studio Community  VS是一个基本完整的开发工具集， Community 版本是一款可供各个开发者、开放源代码项目、学术研究、教育和小型专业团队免费使用的产品。  2. AutoCAD 2016  平面设计主流软件，功能资料齐全，接口相对开放，2016 版相对稳定，基于 .net FrameWork 4.5.2 。 ObjectARX 2016 AutoCAD 2016 开发包。  以下为后期需要的软件 3. git  是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，编程人员必不可少  4. visual studio code  一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。便于文本管理，及其他语言开发工具。  暂时整理以上相关内容，如有其他后续补上。\n","date":"2021-01-06T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/mathcode-data/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"图形计算"},{"content":"分配饼干 Input: grid[1,3], size[1,2,4]\rOutput: 2\rpublic class Solution { public int FindContentChildren(int[] g, int[] s) { Array.Sort(s); Array.Sort(g); int child = 0, cookie = 0; while(child \u0026lt; g.Length \u0026amp;\u0026amp; cookie \u0026lt; s.Length) { if(g[child] \u0026lt;= s[cookie]) child++; cookie++; } return child; } } 不重叠的区间个数 Input: [ [1,2], [1,2], [1,2] ]\rOutput: 2\rInput: [ [1,2], [2,3] ]\rOutput: 0\r","date":"2021-01-04T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2021-01-04/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2021-01-04"},{"content":"按颜色进行排序 Input: [2,0,2,1,1,0]\rOutput: [0,0,1,1,2,2]\rpublic class Solution { public void SortColors(int[] nums) { int z = 0, t = nums.Length - 1; for (int i = 0; i \u0026lt; nums.Length; i++) { if (nums[i] == 0) { int tmp = nums[z]; nums[z++] = nums[i]; nums[i] = tmp; } } for (int i = nums.Length - 1; i \u0026gt;= z; i--) { if (nums[i] == 2) { int tmp = nums[t]; nums[t--] = nums[i]; nums[i] = tmp; } } } } ","date":"2020-12-30T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-30/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-30"},{"content":"按照字符出现次数对字符串排序 Input:\r\u0026quot;tree\u0026quot;\rOutput:\r\u0026quot;eert\u0026quot;\rExplanation:\r'e' appears twice while 'r' and 't' both appear once.\rSo 'e' must appear before both 'r' and 't'. Therefore \u0026quot;eetr\u0026quot; is also a valid answer.\rpublic class Solution { public string FrequencySort(string s) { var list = s.ToCharArray().GroupBy(d =\u0026gt; d) .ToDictionary(d =\u0026gt; d.Key, d =\u0026gt; d.Count()).ToList(); list.Sort((p1, p2) =\u0026gt; p2.Value.CompareTo(p1.Value)); StringBuilder result = new StringBuilder(); foreach (var l in list) for (int i = 0; i \u0026lt; l.Value; i++) result.Append(l.Key); return result.ToString(); } } ","date":"2020-12-29T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-29/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-29"},{"content":"Example: using Autodesk.Windows;\rusing System.Windows.Controls;\r/// \u0026lt;summary\u0026gt;  /// 添加Ribbon选项卡  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ribbonCtrl\u0026#34;\u0026gt;Ribbon控制器\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;title\u0026#34;\u0026gt;选项卡标题\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;ID\u0026#34;\u0026gt;选项卡ID\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;isActive\u0026#34;\u0026gt;是否置为当前\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;RibbonTab\u0026lt;/returns\u0026gt;  internal static RibbonTab AddTab(this RibbonControl ribbonCtrl, string title, string ID, bool isActive) { RibbonTab tab = new RibbonTab(); tab.Title = title; tab.Id = ID; ribbonCtrl.Tabs.Add(tab); tab.IsActive = isActive; return tab; } /// \u0026lt;summary\u0026gt;  /// 添加面板  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;tab\u0026#34;\u0026gt;Ribbon选项卡\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;title\u0026#34;\u0026gt;面板标题\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;RibbonPanelSource\u0026lt;/returns\u0026gt;  internal static RibbonPanelSource AddPanel(this RibbonTab tab, string title) { RibbonPanelSource panelSource = new RibbonPanelSource { Title = title }; RibbonPanel ribbonPanel = new RibbonPanel { Source = panelSource }; tab.Panels.Add(ribbonPanel); return panelSource; } /// \u0026lt;summary\u0026gt;  /// 给面板添加下拉组合按钮  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;panelSource\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;size\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;orient\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  internal static RibbonSplitButton AddSplitButton(this RibbonPanelSource panelSource, string text, RibbonItemSize size, Orientation orient) { RibbonSplitButton splitBtn = new RibbonSplitButton { Text = text, ShowText = true, Size = size, ShowImage = true, Orientation = orient }; panelSource.Items.Add(splitBtn); return splitBtn; } CAD二次开发视频C#语言\n","date":"2020-12-22T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/autocad-ribbon/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"CADRibbon"},{"content":"CAD 开发学习资料集合","date":"2020-12-22T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/autocad-data/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"CAD资料"},{"content":"找到倒数第 k 个的元素 Given [1,1,1,2,2,3] and k = 2, return [1,2].\rpublic class Solution { public int FindKthLargest(int[] nums, int k) { return nums.OrderByDescending(d =\u0026gt; d).ToArray()[k - 1]; } } 出现频率最多的 k 个元素 Given [1,1,1,2,2,3] and k = 2, return [1,2].\rpublic class Solution { public int[] TopKFrequent(int[] nums, int k) { return nums.GroupBy(d =\u0026gt; d) .OrderByDescending(d =\u0026gt; d.Count()) s.Select(d =\u0026gt; d.Key).Take(k).ToArray(); } } ","date":"2020-12-22T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-22/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-22"},{"content":"双指针 判断链表是否存在环 使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。\npublic class Solution { public bool HasCycle(ListNode head) { if(head == null) return false; var l1 = head; var l2 = head.next; while(l1 != null \u0026amp;\u0026amp; l2 != null \u0026amp;\u0026amp; l2.next != null) { if(l1 == l2) return true; l1 = l1.next; l2 = l2.next.next; } return false; } } 最长子序列 Input:\rs = \u0026quot;abpcplea\u0026quot;, d = [\u0026quot;ale\u0026quot;,\u0026quot;apple\u0026quot;,\u0026quot;monkey\u0026quot;,\u0026quot;plea\u0026quot;]\rOutput:\r\u0026quot;apple\u0026quot;\r题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。\npublic class Solution { public string FindLongestWord(string s, IList\u0026lt;string\u0026gt; d) { List\u0026lt;string\u0026gt; vs = new List\u0026lt;string\u0026gt;(); for (int i = 0; i \u0026lt; d.Count; i++) { var target = d[i]; if (target.Length \u0026gt; s.Length || (target.Length == s.Length \u0026amp;\u0026amp; target != s)) continue; if (isSubstr(s, target)) vs.Add(target); } if (vs.Count \u0026gt; 0) return vs.OrderByDescending(d =\u0026gt; d.Length) .ThenBy(d =\u0026gt; d).FirstOrDefault(); else return \u0026#34;\u0026#34;; } private bool isSubstr(string s, string target) { int i = 0, j = 0; while (i \u0026lt; s.Length \u0026amp;\u0026amp; j \u0026lt; target.Length) if (s[i++] == target[j]) j++; return j == target.Length; } } ","date":"2020-12-21T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-21/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-21"},{"content":"回文字符串 Input: \u0026quot;abca\u0026quot;\rOutput: True\rExplanation: You could delete the character 'c'.\r可以删除一个字符，判断是否能构成回文字符串。\npublic class Solution { public bool ValidPalindrome(string s) { for (int i = 0, j = s.Length - 1; i \u0026lt; j; i++, j--) if (s[i] != s[j]) return IsPalindrome(s, i + 1, j) || IsPalindrome(s, i, j - 1); return true; } private static bool IsPalindrome(string s, int i, int j) { while (i \u0026lt; j) if (s[i++] != s[j--]) return false; return true; } } 归并两个有序数组 Input:\rnums1 = [1,2,3,0,0,0], m = 3\rnums2 = [2,5,6], n = 3\rOutput: [1,2,2,3,5,6]\r题目描述：把归并结果存到第一个数组上。\npublic class Solution { public void Merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1, j = n - 1, merge = n + m - 1; while (i \u0026gt;= 0 || j \u0026gt;= 0) nums1[merge--] = i \u0026lt; 0 ? nums2[j--] : j \u0026lt; 0 ? nums1[i--] : nums1[i] \u0026lt;= nums2[j] ? nums2[j--] : nums1[i--]; } } ","date":"2020-12-19T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-19/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-19"},{"content":"双指针 有序数组，两数之和 Input: numbers={2, 7, 11, 15}, target=9\rOutput: index1=1, index2=2\r在有序数组中找出两个数，使它们的和为 target.\npublic class Solution { public int[] TwoSum(int[] numbers, int target) { int i = 0, j = numbers.Length - 1; while (i \u0026lt; j) if (numbers[i] + numbers[j] == target) return new int[]{ i + 1, j + 1 }; else if (numbers[i] + numbers[j] \u0026gt; target) j--; else i++; return new int[]{-1, -1}; } } 两数平方和 Input: 5\rOutput: True\rExplanation: 1 * 1 + 2 * 2 = 5\r判断一个非负整数是否为两个整数的平方和。\npublic class Solution { public bool JudgeSquareSum(int c) { if (c \u0026gt;= 0) { int i = 0, j = Convert.ToInt32(Math.Sqrt(c)); while(i \u0026lt;= j) { int sum = i * i + j * j; if (sum == c) return true; else if (sum \u0026gt; c) j--; else i++; } } return false; } } 反转字符串中的元音字符 Given s = \u0026quot;leetcode\u0026quot;, return \u0026quot;leotcede\u0026quot;.\r使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符\npublic class Solution { public string ReverseVowels(string s) { char[] vowels = new char[] { \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39; }; int i = 0, j = s.Length - 1; char[] result = new char[s.Length]; while (i \u0026lt;= j) { var si = s[i]; var sj = s[j]; if (!vowels.Contains(si)) result[i++] = si; else if (!vowels.Contains(sj)) result[j--] = sj; else { result[i++] = sj; result[j--] = si; } } return new string(result); } } ","date":"2020-12-18T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-18/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-18"},{"content":"这是第一篇博客,记录一下.\n","date":"2020-12-17T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/first-blog/luca-bravo-alS7ewQ41M8-unsplash.jpg","resource":{},"title":"第一篇博客"}]