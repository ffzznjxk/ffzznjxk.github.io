[{"content":"选择集 选择集   获取选择\nEditor.GetSelection()\n  选择的内容\n  SelectionSet = PromptSelectionResult.Value ObjectId[] = SelectionSet.GetObjectIds()\n  类型DxfName\nObjectId.ObjectClass.DxfName\n  /// \u0026lt;summary\u0026gt;  /// 按DxfName分类对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;SED\u0026#34;, CommandFlags.UsePickSet)] public void SelectEntityDxf() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; ////命令之前选中  //var psrAleady = ed.SelectImplied();  //选择集  var pso = new PromptSelectionOptions(); pso.MessageForAdding = \u0026#34;选择对象\\n\u0026#34;; var psr = ed.GetSelection(pso); ////全部选中  //var psrA = ed.SelectAll();  //选择集  //PromptSelectionResult psrPolygon, psrCw, psrW;  ////选择多线段  //var per = ed.GetEntity(new PromptEntityOptions(\u0026#34;选择一条多线段\u0026#34;));  //if (per.Status == PromptStatus.OK)  //{  // //转换多线段  // var pl = per.ObjectId.GetObject(OpenMode.ForRead) as Polyline;  // if (pl != null)  // {  // //顶点集合  // var pts = new Point3dCollection();  // for (int i = 0; i \u0026lt; pl.NumberOfVertices; i++)  // {  // pts.Add(pl.GetPoint3dAt(i));  // }  // //区域选择(叉选)  // psrPolygon = ed.SelectCrossingPolygon(pts);  // }  //}  //if (ed.GetTwoPoints(out Point3d ptStart, out Point3d ptEnd))  //{  // //叉选  // psrCw = ed.SelectCrossingWindow(ptStart, ptEnd);  // //窗选  // psrW = ed.SelectWindow(ptStart, ptEnd);  //}  if (psr.Status == PromptStatus.OK) { ////设置选中内容  //ed.SetImpliedSelection(psrA.Value);  ////清空选中  //ed.SetImpliedSelection(new ObjectId[0]);  //选中对象Id数组  var ids = psr.Value.GetObjectIds(); if (ids.Length \u0026gt; 0) { //按DxfName分组  var gIds = ids.GroupBy(d =\u0026gt; d.ObjectClass.DxfName); //提示信息  string info = string.Empty; foreach (var id in gIds) { info += $\u0026#34;\\n选中 {id.Key} 类型 {id.Count()} 个；\u0026#34;; } AcadApp.ShowAlertDialog(info); ////  //var infos = gIds.Select(d =\u0026gt; $\u0026#34;\\n选中 {d.Key} 类型 {d.Count()} 个；\u0026#34;).ToArray();  //AcadApp.ShowAlertDialog(string.Join(\u0026#34;\\n\u0026#34;, infos));  } } } 条件选择  已选择对象(CommandFlags.UsePickSet)  Editor.SelectImplied()\n 全部选择  Editor.SelectAll();\n 多边形选择  Editor.SelectCrossingPolygon(Point3dCollection polygon)\n 叉选  SelectCrossingWindow(Point3d pt1, Point3d pt2)\n 窗选  SelectWindow(Point3d pt1, Point3d pt2)\n 设置选择内容  SetImpliedSelection(SelectionSet)\n删除对象  实体删除(可写状态)  Entity = (Entity)id.GetObject(OpenMode.ForWrite); Entity.Erase();\n/// \u0026lt;summary\u0026gt;  /// 按DxfName分类对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DE\u0026#34;, CommandFlags.UsePickSet)] public void DeleteEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; //命令之前选中  var psrAleady = ed.SelectImplied(); //选择状态  if (psrAleady.Status == PromptStatus.OK) { //选中对象Id数组  var ids = psrAleady.Value.GetObjectIds(); if (ids.Length \u0026gt; 0) { Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { foreach (var id in ids) { try { //转换为实体对象  var ent = (Entity)id.GetObject(OpenMode.ForWrite); //删除  ent.Erase(); } catch (System.Exception ex) { AcadApp.ShowAlertDialog($\u0026#34;删除失败,原因 {ex.Message}\u0026#34;); } finally { } } tr.Commit(); } } } } 几何变换 矩阵  移动  Matrix3d.Displacement(Point3d.GetVectorTo(Point3d))\n 复制  Database.DeepCloneObjects(ObjectIdCollection identifiers, ObjectId id, IdMapping mapping, bool deferTranslation);\n 旋转  Matrix3d Rotation(double angle, Vector3d axis, Point3d center);\n 镜像  Matrix3d Mirroring(Line3d line(Point3d, Point3d));\n 缩放  Matrix3d Scaling(double scaleAll, Point3d center);\n变换 Entity.TransformBy(Matrix3d);\n/// \u0026lt;summary\u0026gt;  /// 移动对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;ME\u0026#34;)] public void MoveEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { //获取输入的两点  var result = ed.GetTwoPoints(out Point3d ptStart, out Point3d ptEnd); if (result) { //平移向量  var vector = ptEnd - ptStart; //矩阵,平移  var mt = Matrix3d.Displacement(vector); Database db = HostApplicationServices.WorkingDatabase; //开启事务处理  using (var tr = db.TransactionManager.StartTransaction()) { foreach (var id in ids) { //通过Id获取实体  var ent = (Entity)id.GetObject(OpenMode.ForWrite); //实体变换  ent.TransformBy(mt); //降为只读  ent.DowngradeOpen(); } tr.Commit(); } } } } /// \u0026lt;summary\u0026gt;  /// 复制对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;CE\u0026#34;)] public void CopyEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { //获取两点  var result = ed.GetTwoPoints(out Point3d ptStart, out Point3d ptEnd); if (result) { Database db = HostApplicationServices.WorkingDatabase; //  var map = new IdMapping(); ObjectIdCollection srcIds = new ObjectIdCollection(ids); //复制  db.DeepCloneObjects(srcIds, db.CurrentSpaceId, map, false); //平移  var vector = ptEnd.GetVectorTo(ptStart); var mt = Matrix3d.Displacement(vector); //源对象与复制对象字典  Dictionary\u0026lt;ObjectId, ObjectId\u0026gt; dictId = new Dictionary\u0026lt;ObjectId, ObjectId\u0026gt;(); using (var tr = db.TransactionManager.StartTransaction()) { foreach (var id in ids) { var idpair = map[id]; id.EntityTrans(mt); dictId.Add(idpair.Key, idpair.Value); } tr.Commit(); } } } } /// \u0026lt;summary\u0026gt;  /// 旋转对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;ROE\u0026#34;)] public void RotateEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { //获取旋转基点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定旋转中心点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { //旋转基点  var ptBase = ppr.Value; //获取旋转角度  var pao = new PromptAngleOptions(\u0026#34;\\n指定旋转角度\u0026#34;) { //设定旋转基点  BasePoint = ptBase, UseBasePoint = true }; var par = ed.GetAngle(pao); if (par.Status == PromptStatus.OK) { //旋转角度  var angle = par.Value; //矩阵,旋转  var mt = Matrix3d.Rotation(angle, Vector3d.ZAxis, ptBase); Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { //旋转对象  foreach (var id in ids) { id.EntityTrans(mt); } tr.Commit(); } } } } } /// \u0026lt;summary\u0026gt;  /// 镜像对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;MIE\u0026#34;)] public void MirrorEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { var result = ed.GetTwoPoints(out Point3d ptStart, out Point3d ptEnd); if (result) { //镜像线  var miLine = new Line3d(ptStart, ptEnd); //矩阵,镜像  var mt = Matrix3d.Mirroring(miLine); //提示关键字  var pko = new PromptKeywordOptions(\u0026#34;\\n是否删除源对象\u0026#34;); pko.Keywords.Add(\u0026#34;是\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;删除源对象(Y)\u0026#34;); pko.Keywords.Add(\u0026#34;否\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;保留源对象(N)\u0026#34;); pko.Keywords.Default = \u0026#34;否\u0026#34;; pko.AllowNone = true; //获取关键字  var pkr = ed.GetKeywords(pko); Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { //仅镜像  if (pkr.Status == PromptStatus.OK \u0026amp;\u0026amp; pkr.StringResult == \u0026#34;是\u0026#34;) { foreach (var id in ids) { id.EntityTrans(mt); } } //保留源对象镜像  else { foreach (var id in ids) { var ent = (Entity)id.GetObject(OpenMode.ForWrite); var entCopy = ent.GetTransformedCopy(mt); ent.DowngradeOpen(); var mirrorId = db.AddNewEntity(entCopy); } } tr.Commit(); } } } } /// \u0026lt;summary\u0026gt;  /// 缩放对象  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;SCE\u0026#34;)] public void ScaleEntity() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; var ids = ed.GetSelectIds(\u0026#34;选择对象\\n\u0026#34;); if (ids.Length \u0026gt; 0) { //提示缩放点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定缩放点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { //缩放点  var ptBase = ppr.Value; //提示缩放比例  var pdr = ed.GetDouble(new PromptDoubleOptions(\u0026#34;\\n指定缩放比例\u0026#34;)); if (pdr.Status == PromptStatus.OK) { //缩放比例  var scaleFactor = pdr.Value; //矩阵,缩放  var mt = Matrix3d.Scaling(scaleFactor, ptBase); Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { foreach (var id in ids) { id.EntityTrans(mt); } tr.Commit(); } } } } } /// \u0026lt;summary\u0026gt;  /// 绘制箭头  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;MAKEARROR\u0026#34;)] public void MakeArrow() { Editor ed = AcadApp.DocumentManager.MdiActiveDocument.Editor; //指定点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定箭头原点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { //点  var pt = ppr.Value; var pao = new PromptAngleOptions(\u0026#34;\\n指定角度\u0026#34;) { BasePoint = pt, UseBasePoint = true }; var par = ed.GetAngle(pao); if (par.Status == PromptStatus.OK) { //角度  var angle = par.Value; var pdr = ed.GetDouble(new PromptDoubleOptions(\u0026#34;\\n指定比例\u0026#34;)); if (pdr.Status == PromptStatus.OK) { //缩放比例  var scaleFactor = pdr.Value; //提示镜像  var pko = new PromptKeywordOptions(\u0026#34;\\n是否反向\u0026#34;); pko.Keywords.Add(\u0026#34;正向\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;正向(Y)\u0026#34;); pko.Keywords.Add(\u0026#34;反向\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;反向(N)\u0026#34;); pko.Keywords.Default = \u0026#34;正向\u0026#34;; pko.AllowNone = true; var pkr = ed.GetKeywords(pko); //箭头  Polyline pl = DrawArrow(); var mt = new Matrix3d(); //矩阵,平移  mt *= Matrix3d.Displacement(pt.GetAsVector()); //旋转  mt *= Matrix3d.Rotation(angle, Vector3d.ZAxis, Point3d.Origin); ////对称可用旋转 pi  //if (pkr.Status == PromptStatus.OK \u0026amp;\u0026amp; pkr.StringResult == \u0026#34;反向\u0026#34;)  // mt *= Matrix3d.Rotation(Math.PI, Vector3d.ZAxis, Point3d.Origin);  //缩放  mt *= Matrix3d.Scaling(scaleFactor, Point3d.Origin); //反向,  if (pkr.Status == PromptStatus.OK \u0026amp;\u0026amp; pkr.StringResult == \u0026#34;反向\u0026#34;) { //镜像法向量  Vector3d vector = Vector3d.XAxis.RotateBy(Math.PI / 2, Vector3d.ZAxis); var miLine = new Line3d(Point3d.Origin, vector); mt *= Matrix3d.Mirroring(miLine); } //矩阵变换  pl.TransformBy(mt); Database db = HostApplicationServices.WorkingDatabase; //添加对象  db.AddNewEntity(pl); } } } } /// \u0026lt;summary\u0026gt;  /// 箭头图形  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;箭头多线段\u0026lt;/returns\u0026gt;  private static Polyline DrawArrow() { Polyline pl = new Polyline(); pl.AddVertexAt(0, new Point2d(0, 1), 0, 0, 0); pl.AddVertexAt(1, new Point2d(4, 0), 0, 0, 0); pl.AddVertexAt(2, new Point2d(0, -1), 0, 0, 0); pl.Closed = true; return pl; } 函数方法 /// \u0026lt;summary\u0026gt;  /// 获取输入的两点  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ed\u0026#34;\u0026gt;编辑器\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;ptStart\u0026#34;\u0026gt;起点\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;ptEnd\u0026#34;\u0026gt;终点\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;是否完成选择\u0026lt;/returns\u0026gt;  public static bool GetTwoPoints(this Editor ed, out Point3d ptStart, out Point3d ptEnd) { ptStart = Point3d.Origin; ptEnd = Point3d.Origin; var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定起点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { ptStart = ppr.Value; ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定终点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { ptEnd = ppr.Value; return true; } } return false; } /// \u0026lt;summary\u0026gt;  /// 获取选择的对象数组  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ed\u0026#34;\u0026gt;编辑器\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;prompt\u0026#34;\u0026gt;提示\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;对象Id组\u0026lt;/returns\u0026gt;  public static ObjectId[] GetSelectIds(this Editor ed, string prompt) { ObjectId[] ids = new ObjectId[0]; var pso = new PromptSelectionOptions(); pso.MessageForAdding = prompt; var psr = ed.GetSelection(pso); if (psr.Status == PromptStatus.OK) { ids = psr.Value.GetObjectIds(); } return ids; } /// \u0026lt;summary\u0026gt;  /// 对象变换  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;对象Id\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mt\u0026#34;\u0026gt;矩阵\u0026lt;/param\u0026gt;  public static void EntityTrans(this ObjectId id, Matrix3d mt) { var ent = (Entity)id.GetObject(OpenMode.ForWrite); ent.TransformBy(mt); ent.DowngradeOpen(); } ","date":"2021-02-08T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/new-project-3/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"选择集合与几何变换"},{"content":"输入输出 输入  获取点提示 PromptPointOptions() 获取点结果 ed.GetPoint() 状态 PromptStatus.OK  输出  输出信息 ed.WriteMessage()  /// \u0026lt;summary\u0026gt;  /// 提示选择点  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;PromptSelectPoint\u0026#34;)] public void PromptSelectPoint() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取点提示  var ppo = new PromptPointOptions(\u0026#34;\\n指定起点\u0026#34;); //获取点结果  var ppr = ed.GetPoint(ppo); //结果状态为OK  if (ppr.Status == PromptStatus.OK) { //起点  Point3d startPt = ppr.Value; ppo = new PromptPointOptions(\u0026#34;\\n指定终点\u0026#34;); ppr = ed.GetPoint(ppo); if (ppr.Status == PromptStatus.OK) { //终点  Point3d endPt = ppr.Value; //直线  Line line = new Line(startPt, endPt); //图形数据库  Database db = HostApplicationServices.WorkingDatabase; //添加直线  db.AddNewEntity(line); } else { ed.WriteMessage(\u0026#34;\\n取消画线\u0026#34;); } } else { ed.WriteMessage(\u0026#34;\\n取消画线\u0026#34;); } } /// \u0026lt;summary\u0026gt;  /// 连续绘制直线  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;AddLineMultiple\u0026#34;)] public void AddLineMultiple() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取起点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定起点\u0026#34;)); //结果状态为OK  if (ppr.Status == PromptStatus.OK) { //起点  var startPt = ppr.Value; //第一直线终点  ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定下一点\u0026#34;)); //图形数据库  Database db = HostApplicationServices.WorkingDatabase; //结果状态为OK  while (ppr.Status == PromptStatus.OK) { //终点  Point3d endPt = ppr.Value; //直线  Line line = new Line(startPt, endPt); //添加直线  db.AddNewEntity(line); //下一直线起点  startPt = endPt; //获取下一直线终点  ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定下一点\u0026#34;)); } } else { ed.WriteMessage(\u0026#34;\\n取消画线\u0026#34;); } } 几何图形 多线段  Polyline 平行四边形 矩形 正多边形  /// \u0026lt;summary\u0026gt;  /// 提示选择点  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DrawPolyLine\u0026#34;)] public void DrawPolyLine() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取起点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定点\u0026#34;)); //点列表  List\u0026lt;Point3d\u0026gt; pts = new List\u0026lt;Point3d\u0026gt;(); //结果状态为OK  while (ppr.Status == PromptStatus.OK) { //添加点  pts.Add(ppr.Value); //获取下一点  ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定下一点\u0026#34;)); } //点数大于1  if (pts.Count \u0026gt; 1) { //多线  Polyline pl = new Polyline(); //将点加入多线  for (int i = 0; i \u0026lt; pts.Count; i++) { Point3d pt = pts[i]; pl.AddVertexAt(i, new Point2d(pt.X, pt.Y), 0, 0, 0); } //图形数据库  Database db = HostApplicationServices.WorkingDatabase; //添加多线  db.AddNewEntity(pl); } else { ed.WriteMessage(\u0026#34;\\n获得的点少于2个，无法绘制。\u0026#34;); } } /// \u0026lt;summary\u0026gt;  /// 绘制平行四边形  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DrawParallelogram\u0026#34;)] public void DrawParallelogram() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取对象提示  var peo = new PromptEntityOptions(\u0026#34;\\n选择第一条直线\u0026#34;); //拒绝信息  peo.SetRejectMessage(\u0026#34;选择直线\u0026#34;); //只允许直线  peo.AddAllowedClass(typeof(Line), true); //获取对象结果  var per = ed.GetEntity(peo); //结果状态为OK  if (per.Status == PromptStatus.OK) { //图形数据库  Database db = HostApplicationServices.WorkingDatabase; using (var tr = db.TransactionManager.StartTransaction()) { //直线1  var line1 = (Line)per.ObjectId.GetObject(OpenMode.ForRead); //长度大于0  if (line1 != null \u0026amp;\u0026amp; line1.Length \u0026gt; 0) { //获取点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { var pt = ppr.Value; //平行四边形点  List\u0026lt;Point3d\u0026gt; pts = new List\u0026lt;Point3d\u0026gt; { line1.StartPoint, line1.EndPoint, pt, pt - line1.Delta }; //创建多边形  db.CreatePolyline(pts); //删除原线  line1.UpgradeOpen(); line1.Erase(); } } else { ed.WriteMessage(\u0026#34;\\n直线长度过短。\u0026#34;); } tr.Commit(); } } } /// \u0026lt;summary\u0026gt;  /// 绘制矩形  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DrawRectangle\u0026#34;)] public void DrawRectangle() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取第一点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { var pt1 = ppr.Value; //获取角点  ppr = ed.GetCorner(new PromptPointOptions(\u0026#34;\\n指定角点\u0026#34;)); if (ppr.Status == PromptStatus.OK) { var pt2 = ppr.Value; //矩形最大、最小点  Point2d maxPt = new Point2d(Math.Max(pt1.X, pt2.X), Math.Max(pt1.Y, pt2.Y)); Point2d minPt = new Point2d(Math.Min(pt1.X, pt2.X), Math.Min(pt1.Y, pt2.Y)); //边界点  List\u0026lt;Point2d\u0026gt; pts2d = new List\u0026lt;Point2d\u0026gt; { minPt, new Point2d(maxPt.X, minPt.Y), maxPt, new Point2d(minPt.X, maxPt.Y), }; Database db = HostApplicationServices.WorkingDatabase; //绘制矩形  db.CreatePolyline(pts2d); } } } /// \u0026lt;summary\u0026gt;  /// 绘制正多边形  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;DrawRegularPolygon\u0026#34;)] public void DrawRegularPolygon() { //当前文档  Document doc = AcadApp.DocumentManager.MdiActiveDocument; //获得编辑器  Editor ed = doc.Editor; //获取点  var ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定正多边形中心\u0026#34;)); if (ppr.Status != PromptStatus.OK) return; //获取第二点  var pt1 = ppr.Value; ppr = ed.GetPoint(new PromptPointOptions(\u0026#34;\\n指定正多边形角点\u0026#34;)); if (ppr.Status != PromptStatus.OK) return; var pt2 = ppr.Value; //长度  var distance = pt2.DistanceTo(pt1); if (distance == 0) return; //多边形数量  var pio = new PromptIntegerOptions(\u0026#34;\\n输入多边形边数\u0026#34;); var pir = ed.GetInteger(pio); if (pir.Status != PromptStatus.OK) return; int sideNum = pir.Value; //变数不小于3  if (sideNum \u0026lt; 3) return; List\u0026lt;Point2d\u0026gt; pts2d = new List\u0026lt;Point2d\u0026gt;(); //初始角度  var angle = (pt2 - pt1).GetAngleTo(Vector3d.XAxis); //负角度  if (pt2.Y \u0026lt; pt1.Y) angle = -angle; //初始点  for (int i = 0; i \u0026lt; sideNum; i++) { //相对向量  var vector2d = new Vector2d(Math.Cos(angle), Math.Sin(angle)) * distance; //计算点  var pt = pt1.Convert2d() + vector2d; pts2d.Add(pt); //角度增量  angle += Math.PI * 2 / sideNum; } Database db = HostApplicationServices.WorkingDatabase; //添加多边形  db.CreatePolyline(pts2d); } 其他函数 /// \u0026lt;summary\u0026gt;  /// 绘制多线段  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;db\u0026#34;\u0026gt;图形数据库\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;pts2d\u0026#34;\u0026gt;2维点集合\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;closed\u0026#34;\u0026gt;闭合\u0026lt;/param\u0026gt;  public static ObjectId CreatePolyline(this Database db, List\u0026lt;Point2d\u0026gt; pts2d, bool closed = true) { //点数过少返回空  if (pts2d.Count \u0026lt; 2) return ObjectId.Null; //多线  Polyline pl = new Polyline(); //将点加入多线  for (int i = 0; i \u0026lt; pts2d.Count; i++) pl.AddVertexAt(i, pts2d[i], 0, 0, 0); //闭合  pl.Closed = closed; //添加多线  return db.AddNewEntity(pl)[0]; } /// \u0026lt;summary\u0026gt;  /// 绘制多线段  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;db\u0026#34;\u0026gt;图形数据库\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;pts2d\u0026#34;\u0026gt;3d点集合\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;closed\u0026#34;\u0026gt;闭合\u0026lt;/param\u0026gt;  public static ObjectId CreatePolyline(this Database db, List\u0026lt;Point3d\u0026gt; pts, bool closed = true) { //2d点集合  var pts2d = new List\u0026lt;Point2d\u0026gt;(); for (int i = 0; i \u0026lt; pts.Count; i++) pts2d.Add(pts[i].Convert2d()); //var pts2d = pts.Select(p =\u0026gt; new Point2d(p.X, p.Y)).ToList();  return db.CreatePolyline(pts2d, closed); } /// \u0026lt;summary\u0026gt;  /// 3d坐标转2d  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pt\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static Point2d Convert2d(this Point3d pt) { Document doc = AcadApp.DocumentManager.MdiActiveDocument; Editor ed = doc.Editor; return pt.Convert2d(ed.GetPlane()); } /// \u0026lt;summary\u0026gt;  /// 获取法向量平面  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ed\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static Plane GetPlane(this Editor ed) { return new Plane(Point3d.Origin, ed.GetNormal()); } /// \u0026lt;summary\u0026gt;  /// 当前坐标系法向量  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ed\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static Vector3d GetNormal(this Editor ed) { return Vector3d.ZAxis.TransformBy(ed.CurrentUserCoordinateSystem); } ","date":"2021-02-01T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/new-project-2/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"用户交互与几何图形"},{"content":"变化  逆风——花园精灵\n \r图1.gif\r\n\r图2.gif\r\n\r图3.gif\r\n\r图4.gif\r\n\r图5.gif\r\n  飞机云——《起风了》\n 动态的可能\n 设计师的第二插件\n","date":"2021-01-15T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/2020summary/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"2020年记忆"},{"content":"一个新项目 Visual Studio 1. 安装  登陆 语言  2. 创建新项目  解决方案 项目 项  3. HelloWorld  using namespace class  4. 工具  代码片段  5. 调试  断点 条件 监视（自动窗口/局部变量）  AutoCAD 1. 注册 2. 命令  line/point/vector/circle copy/move/scale/mirror block/dim/text  ObjectARX 1. 类库(.Net Framework)  4.5.2 AcDbMgd AcMgd  2. HelloWord  Editor Application  3. 调试  设为启动项 启动外部程序 NetLoad  4. Line  F12 \r  /// \u0026lt;summary\u0026gt;  /// 新建直线(newline)  /// \u0026lt;/summary\u0026gt; [CommandMethod(\u0026#34;newline\u0026#34;)] public void NewLine() { //定义直线，起点：100, 100, 0；终点：300, 200, 0  Line line = new Line(new Point3d(100, 100, 0), new Point3d(300, 200, 0)); //打开当前图形数据库  Database db = HostApplicationServices.WorkingDatabase; //启动事务处理器  using (Transaction tr = db.TransactionManager.StartTransaction()) { //打开块表  BlockTable bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead); //打开块表记录(可写方式)  BlockTableRecord btr = (BlockTableRecord)tr.GetObject(bt[BlockTableRecord.ModelSpace], OpenMode.ForWrite); //添加对象（直线）到块表记录  btr.AppendEntity(line); //块表记录降为只读  btr.DowngradeOpen(); //更新数据  tr.AddNewlyCreatedDBObject(line, true); //提交事务处理  tr.Commit(); } }  封装  /// \u0026lt;summary\u0026gt;  /// 实体工具组  /// \u0026lt;/summary\u0026gt;  public static class EntityTools { /// \u0026lt;summary\u0026gt;  /// 在图形数据库中添加对象  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;db\u0026#34;\u0026gt;图形数据库\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;entitys\u0026#34;\u0026gt;图形组\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;对象Id组\u0026lt;/returns\u0026gt;  public static ObjectId[] AddNewEntity(this Database db, params Entity[] entitys) { //对象Id组  ObjectId[] ids = new ObjectId[entitys.Length]; //启动事务处理器  using (Transaction tr = db.TransactionManager.StartTransaction()) { //打开块表  BlockTable bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead); //打开块表记录(可写方式)  BlockTableRecord btr = (BlockTableRecord)tr.GetObject(bt[BlockTableRecord.ModelSpace], OpenMode.ForWrite); //连续添加图形  for (int i = 0; i \u0026lt; entitys.Length; i++) { //添加对象（直线）到块表记录  ids[i] = btr.AppendEntity(entitys[i]); //更新数据  tr.AddNewlyCreatedDBObject(entitys[i], true); } //块表记录降为只读  btr.DowngradeOpen(); //提交事务处理  tr.Commit(); } //返回对象Id组  return ids; } } 几何计算 直线方程式  Ax + By + C = 0  /// \u0026lt;summary\u0026gt;  /// 直线方程式（Ax + By + C = 0）  /// \u0026lt;/summary\u0026gt;  public struct LineEquation { public double A; public double B; public double C; internal LineEquation(double a = 1, double b = -1, double c = 0) { A = a; B = b; C = c; } }  直线转直线方程式  /// \u0026lt;summary\u0026gt;  /// 两点转直线方程  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pt1\u0026#34;\u0026gt;点1\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;pt2\u0026#34;\u0026gt;点2\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;le\u0026#34;\u0026gt;直线方程式\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;两点重合输出false\u0026lt;/returns\u0026gt;  public static bool Lpp(Point3d pt1, Point3d pt2, out LineEquation le) { le = new LineEquation(1, 0, -pt1.X); var a = pt2.Y - pt1.Y; var b = pt1.X - pt2.X; var c = Math.Sqrt(a * a + b * b); if (c \u0026gt; 0) { le.A = a / c; le.B = b / c; le.C = -le.A * pt1.X - le.B * pt1.Y; return true; } else return false; } /// \u0026lt;summary\u0026gt;  /// 直线转直线方程  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;line\u0026#34;\u0026gt;直线\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;le\u0026#34;\u0026gt;直线方程式\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;直线长度为0输出false\u0026lt;/returns\u0026gt;  public static bool Lel(this LineSegment3d line, out LineEquation le) { return Lpp(line.StartPoint, line.EndPoint, out le); } 直线方程式计算  垂足  /// \u0026lt;summary\u0026gt;  /// 点到直线方程式垂足  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pt\u0026#34;\u0026gt;点\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;le\u0026#34;\u0026gt;直线方程式\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;垂足\u0026lt;/returns\u0026gt;  public static Point3d Ppln(this Point3d pt, LineEquation le) { double d = le.A * pt.X + le.B * pt.Y + le.C; return new Point3d(pt.X - d * le.A, pt.Y - d * le.B, 0); } ","date":"2021-01-09T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/new-project/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"一个新项目"},{"content":"向量投影问题  在一个二维坐标系中一条线段Line_ab，起终点分别为A(100,100)，B(300,200)，一条线段Line_cd，起终点分别为C(100,200)，D(150,225)。 \r已知条件\r 计算Line_cd投影到Line_ab上的线段 ( 如下图所示Line_ef )。 \r计算投影线段\r  \r\n","date":"2021-01-06T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/geomath-problem1/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"几何算法问题1"},{"content":"概况 图形计算编程主要分两部分内容 1. 算法  几何计算 数据运算  2. 编程  C# 方法 AutoCAD 接口  对于平面设计（建筑行业）主要对象是二维图形，用到的几何计算主要与点、线、框的计算方法；数据运算主要是按照功能需求，对已有的数据准确有效处理。 因为平面设计主要使用 AutoCAD 软件开发，而 AutoCAD 支持 .net 开发，其中 C# 语言易于上手，相关功能资料齐全，易于软件开发使用。\n学习资料 1. 几何计算  《几何计算》 何援军 著，该书讲解二维、三维图形基础计算方法，并用 C++ 给出代码示例，是一本很好的几何计算入门书籍。该书没有电子版，可在京东购买。  2. C#  《C#图解教程》（第4版） 该书介绍了 C# 语言特性，用一些图示方法展示基本原理，适合打好编程语言基础。 《C#本质论》（第4版） 适合扩展提高。 C#入门到精通 这是一套比较全面的视频资料，不过需要很多时间浏览，适合看书遇到疑问时找视频相关内容了解。 C# 菜鸟教程 简明的语言教程网站，适合临时找内容。 C# 官方文档 最全最专业的官方文档，适合深入研究。  3. 算法  《算法》（第4版） 一本专业的算法书籍，让计算简单而有效。 算法第四版 - Course课程 这是上面这本书的视频教程。 Leetcode 题解 Leetcode 是一个专门是算法解题网站，这是一个挑选了常用算法的网站，可以学习这些算法用于解决可能的问题。  4. AutoCAD 二次开发  《Auto CAD VBA\u0026amp;VB.NET开发》 增洪飞等 著，一本适合入门，基本了解 AutoCAD 功能的各个方面。 《深入浅出AutoCAD.NET二次开发》 李冠亿 著，根据 AutoCAD.NET 开发接口，介绍各种基础方法。 CAD二次开发视频C#语言 李小科录制，从编程、对象的角度去实现计算、开发等功能，相对容易上手。 AutoCAD 2018 官方文档 官方专业文档，适合深入研究。 AutoCAD 官方博客 适合了解 AutoCAD 最新方法或功能。  需要准备的软件 1. Visual Studio Community  VS是一个基本完整的开发工具集， Community 版本是一款可供各个开发者、开放源代码项目、学术研究、教育和小型专业团队免费使用的产品。  2. AutoCAD 2016  平面设计主流软件，功能资料齐全，接口相对开放，2016 版相对稳定，基于 .net FrameWork 4.5.2 。 ObjectARX 2016 AutoCAD 2016 开发包。  以下为后期需要的软件 3. git  是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，编程人员必不可少  4. visual studio code  一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。便于文本管理，及其他语言开发工具。  暂时整理以上相关内容，如有其他后续补上。\n","date":"2021-01-06T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/mathcode-data/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"图形计算"},{"content":"分配饼干 Input: grid[1,3], size[1,2,4]\rOutput: 2\rpublic class Solution { public int FindContentChildren(int[] g, int[] s) { Array.Sort(s); Array.Sort(g); int child = 0, cookie = 0; while(child \u0026lt; g.Length \u0026amp;\u0026amp; cookie \u0026lt; s.Length) { if(g[child] \u0026lt;= s[cookie]) child++; cookie++; } return child; } } 不重叠的区间个数 Input: [ [1,2], [1,2], [1,2] ]\rOutput: 2\rInput: [ [1,2], [2,3] ]\rOutput: 0\r","date":"2021-01-04T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2021-01-04/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2021-01-04"},{"content":"按颜色进行排序 Input: [2,0,2,1,1,0]\rOutput: [0,0,1,1,2,2]\rpublic class Solution { public void SortColors(int[] nums) { int z = 0, t = nums.Length - 1; for (int i = 0; i \u0026lt; nums.Length; i++) { if (nums[i] == 0) { int tmp = nums[z]; nums[z++] = nums[i]; nums[i] = tmp; } } for (int i = nums.Length - 1; i \u0026gt;= z; i--) { if (nums[i] == 2) { int tmp = nums[t]; nums[t--] = nums[i]; nums[i] = tmp; } } } } ","date":"2020-12-30T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-30/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-30"},{"content":"按照字符出现次数对字符串排序 Input:\r\u0026quot;tree\u0026quot;\rOutput:\r\u0026quot;eert\u0026quot;\rExplanation:\r'e' appears twice while 'r' and 't' both appear once.\rSo 'e' must appear before both 'r' and 't'. Therefore \u0026quot;eetr\u0026quot; is also a valid answer.\rpublic class Solution { public string FrequencySort(string s) { var list = s.ToCharArray().GroupBy(d =\u0026gt; d) .ToDictionary(d =\u0026gt; d.Key, d =\u0026gt; d.Count()).ToList(); list.Sort((p1, p2) =\u0026gt; p2.Value.CompareTo(p1.Value)); StringBuilder result = new StringBuilder(); foreach (var l in list) for (int i = 0; i \u0026lt; l.Value; i++) result.Append(l.Key); return result.ToString(); } } ","date":"2020-12-29T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-29/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-29"},{"content":"Example: using Autodesk.Windows;\rusing System.Windows.Controls;\r/// \u0026lt;summary\u0026gt;  /// 添加Ribbon选项卡  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;ribbonCtrl\u0026#34;\u0026gt;Ribbon控制器\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;title\u0026#34;\u0026gt;选项卡标题\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;ID\u0026#34;\u0026gt;选项卡ID\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;isActive\u0026#34;\u0026gt;是否置为当前\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;RibbonTab\u0026lt;/returns\u0026gt;  internal static RibbonTab AddTab(this RibbonControl ribbonCtrl, string title, string ID, bool isActive) { RibbonTab tab = new RibbonTab(); tab.Title = title; tab.Id = ID; ribbonCtrl.Tabs.Add(tab); tab.IsActive = isActive; return tab; } /// \u0026lt;summary\u0026gt;  /// 添加面板  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;tab\u0026#34;\u0026gt;Ribbon选项卡\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;title\u0026#34;\u0026gt;面板标题\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;RibbonPanelSource\u0026lt;/returns\u0026gt;  internal static RibbonPanelSource AddPanel(this RibbonTab tab, string title) { RibbonPanelSource panelSource = new RibbonPanelSource { Title = title }; RibbonPanel ribbonPanel = new RibbonPanel { Source = panelSource }; tab.Panels.Add(ribbonPanel); return panelSource; } /// \u0026lt;summary\u0026gt;  /// 给面板添加下拉组合按钮  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;panelSource\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;size\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;orient\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  internal static RibbonSplitButton AddSplitButton(this RibbonPanelSource panelSource, string text, RibbonItemSize size, Orientation orient) { RibbonSplitButton splitBtn = new RibbonSplitButton { Text = text, ShowText = true, Size = size, ShowImage = true, Orientation = orient }; panelSource.Items.Add(splitBtn); return splitBtn; } CAD二次开发视频C#语言\n","date":"2020-12-22T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/autocad-ribbon/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"CADRibbon"},{"content":"CAD 开发学习资料集合","date":"2020-12-22T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/autocad-data/florian-klauer-nptLmg6jqDo-unsplash.jpg","resource":{},"title":"CAD资料"},{"content":"找到倒数第 k 个的元素 Given [1,1,1,2,2,3] and k = 2, return [1,2].\rpublic class Solution { public int FindKthLargest(int[] nums, int k) { return nums.OrderByDescending(d =\u0026gt; d).ToArray()[k - 1]; } } 出现频率最多的 k 个元素 Given [1,1,1,2,2,3] and k = 2, return [1,2].\rpublic class Solution { public int[] TopKFrequent(int[] nums, int k) { return nums.GroupBy(d =\u0026gt; d) .OrderByDescending(d =\u0026gt; d.Count()) s.Select(d =\u0026gt; d.Key).Take(k).ToArray(); } } ","date":"2020-12-22T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-22/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-22"},{"content":"双指针 判断链表是否存在环 使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。\npublic class Solution { public bool HasCycle(ListNode head) { if(head == null) return false; var l1 = head; var l2 = head.next; while(l1 != null \u0026amp;\u0026amp; l2 != null \u0026amp;\u0026amp; l2.next != null) { if(l1 == l2) return true; l1 = l1.next; l2 = l2.next.next; } return false; } } 最长子序列 Input:\rs = \u0026quot;abpcplea\u0026quot;, d = [\u0026quot;ale\u0026quot;,\u0026quot;apple\u0026quot;,\u0026quot;monkey\u0026quot;,\u0026quot;plea\u0026quot;]\rOutput:\r\u0026quot;apple\u0026quot;\r题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。\npublic class Solution { public string FindLongestWord(string s, IList\u0026lt;string\u0026gt; d) { List\u0026lt;string\u0026gt; vs = new List\u0026lt;string\u0026gt;(); for (int i = 0; i \u0026lt; d.Count; i++) { var target = d[i]; if (target.Length \u0026gt; s.Length || (target.Length == s.Length \u0026amp;\u0026amp; target != s)) continue; if (isSubstr(s, target)) vs.Add(target); } if (vs.Count \u0026gt; 0) return vs.OrderByDescending(d =\u0026gt; d.Length) .ThenBy(d =\u0026gt; d).FirstOrDefault(); else return \u0026#34;\u0026#34;; } private bool isSubstr(string s, string target) { int i = 0, j = 0; while (i \u0026lt; s.Length \u0026amp;\u0026amp; j \u0026lt; target.Length) if (s[i++] == target[j]) j++; return j == target.Length; } } ","date":"2020-12-21T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-21/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-21"},{"content":"回文字符串 Input: \u0026quot;abca\u0026quot;\rOutput: True\rExplanation: You could delete the character 'c'.\r可以删除一个字符，判断是否能构成回文字符串。\npublic class Solution { public bool ValidPalindrome(string s) { for (int i = 0, j = s.Length - 1; i \u0026lt; j; i++, j--) if (s[i] != s[j]) return IsPalindrome(s, i + 1, j) || IsPalindrome(s, i, j - 1); return true; } private static bool IsPalindrome(string s, int i, int j) { while (i \u0026lt; j) if (s[i++] != s[j--]) return false; return true; } } 归并两个有序数组 Input:\rnums1 = [1,2,3,0,0,0], m = 3\rnums2 = [2,5,6], n = 3\rOutput: [1,2,2,3,5,6]\r题目描述：把归并结果存到第一个数组上。\npublic class Solution { public void Merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1, j = n - 1, merge = n + m - 1; while (i \u0026gt;= 0 || j \u0026gt;= 0) nums1[merge--] = i \u0026lt; 0 ? nums2[j--] : j \u0026lt; 0 ? nums1[i--] : nums1[i] \u0026lt;= nums2[j] ? nums2[j--] : nums1[i--]; } } ","date":"2020-12-19T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-19/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-19"},{"content":"双指针 有序数组，两数之和 Input: numbers={2, 7, 11, 15}, target=9\rOutput: index1=1, index2=2\r在有序数组中找出两个数，使它们的和为 target.\npublic class Solution { public int[] TwoSum(int[] numbers, int target) { int i = 0, j = numbers.Length - 1; while (i \u0026lt; j) if (numbers[i] + numbers[j] == target) return new int[]{ i + 1, j + 1 }; else if (numbers[i] + numbers[j] \u0026gt; target) j--; else i++; return new int[]{-1, -1}; } } 两数平方和 Input: 5\rOutput: True\rExplanation: 1 * 1 + 2 * 2 = 5\r判断一个非负整数是否为两个整数的平方和。\npublic class Solution { public bool JudgeSquareSum(int c) { if (c \u0026gt;= 0) { int i = 0, j = Convert.ToInt32(Math.Sqrt(c)); while(i \u0026lt;= j) { int sum = i * i + j * j; if (sum == c) return true; else if (sum \u0026gt; c) j--; else i++; } } return false; } } 反转字符串中的元音字符 Given s = \u0026quot;leetcode\u0026quot;, return \u0026quot;leotcede\u0026quot;.\r使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符\npublic class Solution { public string ReverseVowels(string s) { char[] vowels = new char[] { \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39; }; int i = 0, j = s.Length - 1; char[] result = new char[s.Length]; while (i \u0026lt;= j) { var si = s[i]; var sj = s[j]; if (!vowels.Contains(si)) result[i++] = si; else if (!vowels.Contains(sj)) result[j--] = sj; else { result[i++] = sj; result[j--] = si; } } return new string(result); } } ","date":"2020-12-18T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/leetcode-2020-12-18/helena-hertz-wWZzXlDpMog-unsplash.jpg","resource":{},"title":"算法学习2020-12-18"},{"content":"这是第一篇博客,记录一下.\n","date":"2020-12-17T00:00:00Z","exists":true,"isDefault":false,"permalink":"/p/first-blog/luca-bravo-alS7ewQ41M8-unsplash.jpg","resource":{},"title":"第一篇博客"}]